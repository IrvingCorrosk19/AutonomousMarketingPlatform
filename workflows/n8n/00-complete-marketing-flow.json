{
  "name": "Complete Marketing Flow - Integrated",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "marketing-request",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Receive Request",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "complete-marketing-flow-webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "tenantId",
              "value": "={{ $json.body.tenantId }}",
              "type": "string"
            },
            {
              "name": "userId",
              "value": "={{ $json.body.userId }}",
              "type": "string"
            },
            {
              "name": "instruction",
              "value": "={{ $json.body.instruction }}",
              "type": "string"
            },
            {
              "name": "campaignId",
              "value": "={{ $json.body.campaignId ?? null }}",
              "type": "string"
            },
            {
              "name": "requiresApproval",
              "value": "={{ Boolean($json.body.requiresApproval) }}",
              "type": "boolean"
            },
            {
              "name": "channelsNormalized",
              "value": "={{ Array.isArray($json.body.channels) ? $json.body.channels : ($json.body.channels ? [$json.body.channels] : []) }}",
              "type": "array"
            },
            {
              "name": "assets",
              "value": "={{ Array.isArray($json.body.assets) ? $json.body.assets : ($json.body.assets ? [$json.body.assets] : []) }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "id": "normalize-payload",
      "name": "Normalize Payload",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "combinator": "and",
          "options": {
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.tenantId }}",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "leftValue": "={{ $json.userId }}",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "leftValue": "={{ $json.instruction }}",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "leftValue": "={{ Number($json.channelsNormalized.length) }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "larger"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "validate-fields",
      "name": "Validate Required Fields",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: false, error: 'Missing required fields', message: 'The request must include: tenantId, userId, instruction, channels, and requiresApproval' } }}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "respond-validation-error",
      "name": "Respond - Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [850, 200]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}",
              "type": "string"
            },
            {
              "name": "userId",
              "value": "={{ $json.userId }}",
              "type": "string"
            },
            {
              "name": "campaignId",
              "value": "={{ $json.campaignId ?? null }}",
              "type": "string"
            },
            {
              "name": "instruction",
              "value": "={{ $json.instruction }}",
              "type": "string"
            },
            {
              "name": "channels",
              "value": "={{ $json.channelsNormalized }}",
              "type": "array"
            },
            {
              "name": "assets",
              "value": "={{ $json.assets }}",
              "type": "array"
            },
            {
              "name": "requiresApproval",
              "value": "={{ $json.requiresApproval }}",
              "type": "boolean"
            },
            {
              "name": "validatedData",
              "value": "={{ { tenantId: $json.tenantId, userId: $json.userId, campaignId: $json.campaignId ?? null, instruction: $json.instruction, channels: $json.channelsNormalized, assets: $json.assets, requiresApproval: $json.requiresApproval, receivedAt: $now, requestId: $execution.id } }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "id": "set-validated-data",
      "name": "Set Validated Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/ConsentsApi/check",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "userId",
              "value": "={{ $json.userId }}"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "http-check-consents",
      "name": "HTTP Request - Check Consents",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "aiConsent",
              "value": "={{ Boolean($json.aiConsent ?? $json.data?.aiConsent ?? $json.AiConsent ?? false) }}",
              "type": "boolean"
            },
            {
              "name": "publishingConsent",
              "value": "={{ Boolean($json.publishingConsent ?? $json.data?.publishingConsent ?? $json.PublishingConsent ?? false) }}",
              "type": "boolean"
            },
            {
              "name": "tenantId",
              "value": "={{ $('Set Validated Data').item.json.tenantId }}",
              "type": "string"
            },
            {
              "name": "userId",
              "value": "={{ $('Set Validated Data').item.json.userId }}",
              "type": "string"
            },
            {
              "name": "campaignId",
              "value": "={{ $('Set Validated Data').item.json.campaignId }}",
              "type": "string"
            },
            {
              "name": "instruction",
              "value": "={{ $('Set Validated Data').item.json.instruction }}",
              "type": "string"
            },
            {
              "name": "channels",
              "value": "={{ $('Set Validated Data').item.json.channels }}",
              "type": "array"
            },
            {
              "name": "assets",
              "value": "={{ $('Set Validated Data').item.json.assets }}",
              "type": "array"
            },
            {
              "name": "requiresApproval",
              "value": "={{ $('Set Validated Data').item.json.requiresApproval }}",
              "type": "boolean"
            },
            {
              "name": "validatedData",
              "value": "={{ $('Set Validated Data').item.json.validatedData }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "id": "normalize-consents",
      "name": "Normalize Consents",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1450, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.aiConsent }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "leftValue": "={{ $json.publishingConsent }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validate-consents",
      "name": "Validate Consents",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1650, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success:false, error:'Missing consents', message:'User does not have required consents to proceed', aiConsent:$json.aiConsent, publishingConsent:$json.publishingConsent } }}",
        "options": {
          "responseCode": 403
        }
      },
      "id": "respond-consent-error",
      "name": "Respond - Consent Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "userId",
              "value": "={{ $json.userId }}"
            },
            {
              "name": "campaignId",
              "value": "={{ $json.campaignId }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-load-memory",
      "name": "HTTP Request - Load Marketing Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1850, 500]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "memory",
              "value": "={{ { preferredTone: $json.preferences?.preferredTone || 'profesional', dislikedFormats: $json.preferences?.dislikedFormats || [], bestPerformingChannels: $json.learnings?.bestPerformingChannels || [], restrictions: $json.restrictions || [], userPreferences: $json.userPreferences || [], recentConversations: $json.recentConversations || [], campaignMemories: $json.campaignMemories || [], learnings: $json.learnings || {} } }}",
              "type": "object"
            },
            {
              "name": "tenantId",
              "value": "={{ $('Normalize Consents').item.json.tenantId }}",
              "type": "string"
            },
            {
              "name": "userId",
              "value": "={{ $('Normalize Consents').item.json.userId }}",
              "type": "string"
            },
            {
              "name": "instruction",
              "value": "={{ $('Normalize Consents').item.json.instruction }}",
              "type": "string"
            },
            {
              "name": "channels",
              "value": "={{ $('Normalize Consents').item.json.channels }}",
              "type": "array"
            },
            {
              "name": "assets",
              "value": "={{ $('Normalize Consents').item.json.assets }}",
              "type": "array"
            },
            {
              "name": "campaignId",
              "value": "={{ $('Normalize Consents').item.json.campaignId }}",
              "type": "string"
            },
            {
              "name": "requiresApproval",
              "value": "={{ $('Normalize Consents').item.json.requiresApproval }}",
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "id": "normalize-memory",
      "name": "Normalize Memory",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [2050, 500]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Preference"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-load-preference-memory",
      "name": "HTTP Request - Load Preference Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Learning"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-load-performance-memory",
      "name": "HTTP Request - Load Performance Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 500]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Feedback"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-load-constraint-memory",
      "name": "HTTP Request - Load Constraint Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 600]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Pattern"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-load-pattern-memory",
      "name": "HTTP Request - Load Pattern Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 700]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "orderBy",
              "value": "cognitiveVersion"
            },
            {
              "name": "limit",
              "value": "1"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-get-last-cognitive-version",
      "name": "HTTP Request - Get Last Cognitive Version",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 800]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar las 4 memorias avanzadas\nconst preferenceMemory = $('HTTP Request - Load Preference Memory').item?.json || {};\nconst performanceMemory = $('HTTP Request - Load Performance Memory').item?.json || {};\nconst constraintMemory = $('HTTP Request - Load Constraint Memory').item?.json || {};\nconst patternMemoryData = $('HTTP Request - Load Pattern Memory').item?.json || {};\nconst baseData = $('Normalize Memory').item.json;\n\n// Obtener lastCognitiveVersion de HTTP Request - Get Last Cognitive Version\nconst lastCognitiveVersionResponse = $('HTTP Request - Get Last Cognitive Version').item?.json || {};\nconst lastPack = Array.isArray(lastCognitiveVersionResponse) ? \n  (lastCognitiveVersionResponse[0] || {}) : \n  (lastCognitiveVersionResponse.data?.[0] || lastCognitiveVersionResponse);\nconst lastCognitiveVersion = lastPack?.cognitiveVersion ?? \n  (lastPack?.metadata ? (JSON.parse(lastPack.metadata)?.cognitiveVersion ?? null) : null) ?? 1;\n\n// Extraer patrones fallidos y exitosos de PatternMemory\n// Los patrones vienen como memorias individuales, necesitamos parsearlas\nconst patternMemories = Array.isArray(patternMemoryData) ? patternMemoryData : (patternMemoryData.data ? patternMemoryData.data : []);\nconst failedPatterns = [];\nconst successfulPatterns = [];\n\n// BLOQUEO TEMPORAL: Identificar patrones fallidos repetidamente\n// FASE 3: Soporte para severity/blockStatus determinístico\nconst patternFailureCount = {};\nconst blockedPatterns = [];\nconst patternTimestamps = {};\n\n// Función determinística para calcular días desde timestamp\nfunction daysSinceTimestamp(timestamp, referenceTimestamp) {\n  if (!timestamp || !referenceTimestamp) return 999; // Si no hay timestamp, asumir muy antiguo\n  try {\n    const ts = new Date(timestamp).getTime();\n    const ref = new Date(referenceTimestamp).getTime();\n    if (isNaN(ts) || isNaN(ref)) return 999;\n    return Math.round(((ref - ts) / (1000 * 60 * 60 * 24)) * 10000) / 10000; // Redondear a 4 decimales\n  } catch (e) {\n    return 999;\n  }\n}\n\n// Obtener timestamp de referencia determinístico (del validatedData si existe)\nconst validatedData = $('Set Validated Data').item?.json?.validatedData || {};\nconst referenceTimestamp = validatedData.receivedAt || new Date().toISOString();\n\npatternMemories.forEach(memory => {\n  try {\n    const content = typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n    const pattern = content.pattern || JSON.stringify(content);\n    \n    if (content.result === 'negative' || (content.penalty && content.penalty < 0) || content.result === 'override_result') {\n      // Contar fallos por patrón\n      patternFailureCount[pattern] = (patternFailureCount[pattern] || 0) + 1;\n      const memoryTimestamp = content.timestamp || content.context?.evaluationTime || referenceTimestamp;\n      patternTimestamps[pattern] = memoryTimestamp;\n      \n      // Extraer severity si existe (de Fase 3)\n      const severity = content.severity || 'moderate'; // Default si no existe\n      const penalty = Math.round((content.penalty || -0.2) * 10000) / 10000; // Redondear a 4 decimales\n      \n      // Calcular días desde fallo (determinístico)\n      const daysSinceFailure = daysSinceTimestamp(memoryTimestamp, referenceTimestamp);\n      \n      // Si un patrón falla 3+ veces, bloquearlo temporalmente (30 días)\n      if (patternFailureCount[pattern] >= 3 && daysSinceFailure < 30) {\n        blockedPatterns.push(pattern);\n      }\n      \n      failedPatterns.push({ \n        pattern: pattern, \n        failureCount: patternFailureCount[pattern], \n        penalty: penalty,\n        severity: severity,\n        timestamp: memoryTimestamp,\n        daysSinceFailure: daysSinceFailure\n      });\n    } else if (content.result === 'positive' || (content.penalty && content.penalty > 0)) {\n      const penalty = Math.round((content.penalty || 0.1) * 10000) / 10000; // Redondear a 4 decimales\n      successfulPatterns.push({ pattern: pattern, penalty: penalty });\n    }\n  } catch (e) {\n    // Ignorar errores de parsing\n  }\n});\n\n// Extraer datos estructurados de cada tipo de memoria\nconst advancedMemory = {\n  preferenceMemory: {\n    preferredTone: preferenceMemory.preferences?.preferredTone || baseData.memory?.preferredTone || 'profesional',\n    preferredFormats: preferenceMemory.preferences?.preferredFormats || [],\n    preferredChannels: preferenceMemory.preferences?.preferredChannels || [],\n    dislikedFormats: preferenceMemory.preferences?.dislikedFormats || baseData.memory?.dislikedFormats || [],\n    stylePreferences: preferenceMemory.preferences?.stylePreferences || {}\n  },\n  performanceMemory: {\n    bestPerformingChannels: performanceMemory.learnings?.bestPerformingChannels || baseData.memory?.bestPerformingChannels || [],\n    channelKPIs: performanceMemory.learnings?.channelKPIs || {},\n    bestTimes: performanceMemory.learnings?.bestTimes || [],\n    bestDays: performanceMemory.learnings?.bestDays || [],\n    avgCTR: performanceMemory.learnings?.avgCTR || 0,\n    avgEngagement: performanceMemory.learnings?.avgEngagement || 0,\n    topPerformers: performanceMemory.learnings?.topPerformers || []\n  },\n  constraintMemory: {\n    restrictions: constraintMemory.restrictions || baseData.memory?.restrictions || [],\n    prohibitedChannels: constraintMemory.restrictions?.filter(r => r.includes('channel') || r.includes('prohibited')) || [],\n    legalConstraints: constraintMemory.restrictions?.filter(r => r.includes('legal') || r.includes('compliance')) || [],\n    brandConstraints: constraintMemory.restrictions?.filter(r => r.includes('brand') || r.includes('guidelines')) || []\n  },\n  patternMemory: {\n    successfulPatterns: successfulPatterns,\n    failedPatterns: failedPatterns,\n    blockedPatterns: blockedPatterns,\n    patternFailureCount: patternFailureCount,\n    patternTimestamps: patternTimestamps,\n    urgencyFormatMapping: patternMemoryData.urgencyFormatMapping || {},\n    channelFormatMapping: patternMemoryData.channelFormatMapping || {},\n    toneChannelMapping: patternMemoryData.toneChannelMapping || {}\n  }\n};\n\n// Calcular confidence weights basados en historial\nconst confidenceWeights = {\n  channel: calculateChannelConfidence(advancedMemory.performanceMemory.bestPerformingChannels, advancedMemory.performanceMemory.channelKPIs),\n  format: calculateFormatConfidence(advancedMemory.patternMemory.urgencyFormatMapping, advancedMemory.performanceMemory.topPerformers),\n  tone: calculateToneConfidence(advancedMemory.performanceMemory.topPerformers, advancedMemory.patternMemory.toneChannelMapping),\n  timing: calculateTimingConfidence(advancedMemory.performanceMemory.bestTimes, advancedMemory.performanceMemory.bestDays)\n};\n\nfunction calculateChannelConfidence(bestChannels, channelKPIs) {\n  const weights = {};\n  if (bestChannels && bestChannels.length > 0) {\n    bestChannels.forEach((channel, index) => {\n      const kpi = channelKPIs[channel] || {};\n      const ctr = kpi.ctr || 0;\n      const engagement = kpi.engagement || 0;\n      \n      // AUTO-AJUSTE: Penaliza canales con bajo rendimiento y refuerza exitosos\n      let baseWeight = 0.5 + (ctr * 10) + (engagement * 5); // CTR y engagement influyen directamente\n      \n      // Penalización fuerte si CTR < 0.5% o engagement < 1%\n      if (ctr < 0.005) baseWeight -= 0.3;\n      if (engagement < 0.01) baseWeight -= 0.2;\n      \n      // Refuerzo si CTR > 2% o engagement > 5%\n      if (ctr > 0.02) baseWeight += 0.2;\n      if (engagement > 0.05) baseWeight += 0.15;\n      \n      // Ajuste por posición (los primeros tienen más peso)\n      baseWeight -= (index * 0.05);\n      \n      weights[channel] = Math.max(0.1, Math.min(0.9, baseWeight));\n    });\n  }\n  return weights;\n}\n\nfunction calculateFormatConfidence(urgencyFormatMapping, topPerformers) {\n  const weights = {};\n  \n  // AUTO-AJUSTE: Refuerza formatos exitosos y penaliza fallidos\n  if (urgencyFormatMapping && Object.keys(urgencyFormatMapping).length > 0) {\n    Object.entries(urgencyFormatMapping).forEach(([urgency, format]) => {\n      // Si está en el mapeo, es porque ha sido exitoso\n      weights[`${urgency}_${format}`] = 0.75; // Aumentado de 0.7 a 0.75\n    });\n  }\n  \n  if (topPerformers && topPerformers.length > 0) {\n    topPerformers.forEach((performer, index) => {\n      if (performer.format) {\n        // Los top performers refuerzan más\n        const boost = 0.15 - (index * 0.02); // Más boost para los primeros\n        weights[performer.format] = (weights[performer.format] || 0.5) + boost;\n      }\n    });\n  }\n  \n  // Normalizar todos los pesos\n  Object.keys(weights).forEach(key => {\n    weights[key] = Math.max(0.1, Math.min(0.9, weights[key]));\n  });\n  \n  return weights;\n}\n\nfunction calculateToneConfidence(topPerformers, toneChannelMapping) {\n  const weights = {};\n  \n  // AUTO-AJUSTE: Refuerza tonos con alto engagement y penaliza los de bajo rendimiento\n  if (topPerformers && topPerformers.length > 0) {\n    topPerformers.forEach((performer, index) => {\n      if (performer.tone) {\n        // Más refuerzo para los primeros (mejores performers)\n        const boost = 0.12 - (index * 0.015);\n        weights[performer.tone] = (weights[performer.tone] || 0.5) + boost;\n      }\n    });\n  }\n  \n  if (toneChannelMapping && Object.keys(toneChannelMapping).length > 0) {\n    Object.entries(toneChannelMapping).forEach(([tone, channels]) => {\n      if (Array.isArray(channels) && channels.length > 0) {\n        // Más canales = más refuerzo\n        const boost = 0.15 + (channels.length * 0.02);\n        weights[tone] = (weights[tone] || 0.5) + boost;\n      }\n    });\n  }\n  \n  // Normalizar todos los pesos\n  Object.keys(weights).forEach(key => {\n    weights[key] = Math.max(0.1, Math.min(0.9, weights[key]));\n  });\n  \n  return weights;\n}\n\nfunction calculateTimingConfidence(bestTimes, bestDays) {\n  const weights = { times: {}, days: {} };\n  if (bestTimes && bestTimes.length > 0) {\n    bestTimes.forEach(time => {\n      weights.times[time] = 0.7;\n    });\n  }\n  if (bestDays && bestDays.length > 0) {\n    bestDays.forEach(day => {\n      weights.days[day] = 0.7;\n    });\n  }\n  return weights;\n}\n\n// AUTO-AJUSTE: Aplicar penalizaciones automáticas a patrones fallidos\n// BLOQUEO TEMPORAL: Excluir patrones bloqueados\nconst avoidPatterns = failedPatterns\n  .filter(pattern => {\n    const patternStr = typeof pattern === 'object' ? pattern.pattern : pattern;\n    return !blockedPatterns.includes(patternStr);\n  })\n  .map(pattern => {\n    // Si el patrón tiene penalización negativa, se evita más\n    if (typeof pattern === 'object' && pattern.penalty && pattern.penalty < 0) {\n      return pattern.pattern || JSON.stringify(pattern);\n    }\n    return typeof pattern === 'string' ? pattern : (pattern.pattern || JSON.stringify(pattern));\n  });

return {\n  ...baseData,\n  advancedMemory: advancedMemory,\n  confidenceWeights: confidenceWeights,\n  learnedBestChannels: advancedMemory.performanceMemory.bestPerformingChannels || [],\n  avoidPatterns: avoidPatterns,\n  preferredFormats: advancedMemory.preferenceMemory.preferredFormats || [],\n  successfulPatterns: successfulPatterns,\n  lastCognitiveVersion: lastCognitiveVersion\n};"
      },
      "id": "consolidate-advanced-memory",
      "name": "Consolidate Advanced Memory",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 500]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "create",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Eres un analizador experto de instrucciones de marketing con acceso a memoria cognitiva avanzada. Tu tarea es analizar la instrucción del usuario y extraer información estructurada, PRIORIZANDO automáticamente canales, formatos y tonos con mejor performance histórica. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\n\n{\n  \"objective\": \"string - objetivo principal de la instrucción\",\n  \"tone\": \"string - tono recomendado (profesional, casual, formal, amigable, técnico, etc.) - PRIORIZA tonos con mayor engagement histórico\",\n  \"urgency\": \"string - nivel de urgencia (low, medium, high, critical)\",\n  \"contentType\": \"string - tipo de contenido recomendado (post, story, reel, video, carousel, article, etc.) - PRIORIZA formatos exitosos para esta urgencia\",\n  \"targetAudience\": \"string - audiencia objetivo si se menciona\",\n  \"keyMessages\": [\"string\"],\n  \"hashtags\": [\"string\"],\n  \"channels\": [\"string\"] - PRIORIZA canales con mejor performance histórica\n}"
            },
            {
              "role": "user",
              "content": "={{ 'Analiza la siguiente instrucción de marketing y extrae la información estructurada, PRIORIZANDO automáticamente basándote en el aprendizaje histórico:\\n\\n## Instrucción:\\n' + $json.instruction + '\\n\\n## Memoria Cognitiva Avanzada:\\n' + JSON.stringify({ learnedBestChannels: $json.learnedBestChannels || [], avoidPatterns: $json.avoidPatterns || [], preferredFormats: $json.preferredFormats || [], confidenceWeights: $json.confidenceWeights || {} }, null, 2) + '\\n\\nResponde SOLO con el JSON, sin texto adicional.' }}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 500
        },
        "authentication": "openAiApi"
      },
      "id": "openai-analyze",
      "name": "OpenAI - Analyze Instruction (Cognitive)",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [2250, 500],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI\nconst response = $input.item.json;\nlet analysis = {};\n\ntry {\n  let content = response.choices?.[0]?.message?.content || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  analysis = JSON.parse(content);\n} catch (error) {\n  try {\n    const jsonMatch = response.choices?.[0]?.message?.content?.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      analysis = JSON.parse(jsonMatch[0]);\n    } else {\n      analysis = {\n        objective: 'No se pudo determinar',\n        tone: 'profesional',\n        urgency: 'medium',\n        contentType: 'post',\n        targetAudience: '',\n        keyMessages: [],\n        hashtags: [],\n        channels: []\n      };\n    }\n  } catch (parseError) {\n    analysis = {\n      objective: 'Error al analizar',\n      tone: 'profesional',\n      urgency: 'medium',\n      contentType: 'post',\n      targetAudience: '',\n      keyMessages: [],\n      hashtags: [],\n      channels: []\n    };\n  }\n}\n\nconst memory = $('Normalize Memory').item.json.memory || {};\nconst result = {\n  objective: analysis.objective || 'No especificado',\n  tone: analysis.tone || memory.preferredTone || 'profesional',\n  urgency: analysis.urgency || 'medium',\n  contentType: analysis.contentType || 'post',\n  targetAudience: analysis.targetAudience || '',\n  keyMessages: Array.isArray(analysis.keyMessages) ? analysis.keyMessages : [],\n  hashtags: Array.isArray(analysis.hashtags) ? analysis.hashtags : [],\n  channels: Array.isArray(analysis.channels) ? analysis.channels : ($('Normalize Memory').item.json.channels || []),\n  originalInstruction: $('Normalize Memory').item.json.instruction,\n  analyzedAt: new Date().toISOString(),\n  tenantId: $('Normalize Memory').item.json.tenantId || '',\n  userId: $('Normalize Memory').item.json.userId || ''\n};\n\nreturn {\n  ...$('Normalize Memory').item.json,\n  analysis: result\n};"
      },
      "id": "parse-analysis",
      "name": "Parse Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 500]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "create",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Eres un estratega de marketing experto. Tu tarea es generar una estrategia de marketing completa basada en el análisis de la instrucción del usuario y la memoria histórica del tenant. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\n\n{\n  \"mainMessage\": \"string - mensaje principal de la campaña\",\n  \"cta\": \"string - call to action claro y directo\",\n  \"recommendedFormat\": \"string - formato recomendado (post, story, reel, video, carousel, article)\",\n  \"suggestedSchedule\": {\n    \"bestDays\": [\"string\"],\n    \"bestTimes\": [\"string\"],\n    \"timezone\": \"string\"\n  },\n  \"contentStructure\": {\n    \"headline\": \"string\",\n    \"body\": \"string\",\n    \"hashtags\": [\"string\"],\n    \"mentions\": [\"string\"]\n  },\n  \"channels\": [\"string\"],\n  \"tone\": \"string\",\n  \"targetAudience\": \"string\",\n  \"keyPoints\": [\"string\"]\n}"
            },
            {
              "role": "user",
              "content": "={{ 'Genera una estrategia de marketing completa basada en la siguiente información, PRIORIZANDO automáticamente decisiones con mayor probabilidad de éxito según el aprendizaje histórico:\\n\\n## Análisis de la Instrucción:\\n' + JSON.stringify($json.analysis, null, 2) + '\\n\\n## Memoria Cognitiva Avanzada:\\n' + JSON.stringify({ learnedBestChannels: $json.learnedBestChannels || [], avoidPatterns: $json.avoidPatterns || [], preferredFormats: $json.preferredFormats || [], confidenceWeights: $json.confidenceWeights || {}, performanceMemory: $json.advancedMemory?.performanceMemory || {}, patternMemory: $json.advancedMemory?.patternMemory || {} }, null, 2) + '\\n\\n## Memoria Histórica del Tenant:\\n' + JSON.stringify($json.memory, null, 2) + '\\n\\nConsidera y PRIORIZA:\\n- Canales con mejor performance histórica (confidenceWeights.channel)\\n- Formatos exitosos para esta urgencia (patternMemory.urgencyFormatMapping)\\n- Tonos con mayor engagement (confidenceWeights.tone)\\n- Horarios óptimos (confidenceWeights.timing)\\n- EVITA patrones fallidos (avoidPatterns)\\n- El objetivo identificado en el análisis\\n- Las restricciones y aprendizajes\\n\\nResponde SOLO con el JSON de la estrategia, sin texto adicional.' }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 1000
        },
        "authentication": "openAiApi"
      },
      "id": "openai-strategy",
      "name": "OpenAI - Generate Strategy",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [2650, 500],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI\nconst response = $input.item.json;\nlet strategy = {};\n\ntry {\n  let content = response.choices?.[0]?.message?.content || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  strategy = JSON.parse(content);\n} catch (error) {\n  try {\n    const jsonMatch = response.choices?.[0]?.message?.content?.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      strategy = JSON.parse(jsonMatch[0]);\n    } else {\n      const analysis = $('Parse Analysis').item.json.analysis || {};\n      strategy = {\n        mainMessage: analysis.objective || 'Mensaje principal de la campaña',\n        cta: 'Descubre más',\n        recommendedFormat: analysis.contentType || 'post',\n        suggestedSchedule: { bestDays: ['lunes', 'miércoles', 'viernes'], bestTimes: ['09:00', '13:00', '18:00'], timezone: 'UTC' },\n        contentStructure: { headline: analysis.objective || '', body: '', hashtags: analysis.hashtags || [], mentions: [] },\n        channels: analysis.channels || [],\n        tone: analysis.tone || 'profesional',\n        targetAudience: analysis.targetAudience || '',\n        keyPoints: analysis.keyMessages || []\n      };\n    }\n  } catch (parseError) {\n    const analysis = $('Parse Analysis').item.json.analysis || {};\n    strategy = {\n      mainMessage: 'Estrategia de marketing',\n      cta: 'Descubre más',\n      recommendedFormat: 'post',\n      suggestedSchedule: { bestDays: ['lunes', 'miércoles', 'viernes'], bestTimes: ['09:00', '13:00', '18:00'], timezone: 'UTC' },\n      contentStructure: { headline: '', body: '', hashtags: [], mentions: [] },\n      channels: [],\n      tone: 'profesional',\n      targetAudience: '',\n      keyPoints: []\n    };\n  }\n}\n\nconst finalStrategy = {\n  mainMessage: strategy.mainMessage || 'Mensaje principal de la campaña',\n  cta: strategy.cta || 'Descubre más',\n  recommendedFormat: strategy.recommendedFormat || 'post',\n  suggestedSchedule: {\n    bestDays: Array.isArray(strategy.suggestedSchedule?.bestDays) ? strategy.suggestedSchedule.bestDays : ['lunes', 'miércoles', 'viernes'],\n    bestTimes: Array.isArray(strategy.suggestedSchedule?.bestTimes) ? strategy.suggestedSchedule.bestTimes : ['09:00', '13:00', '18:00'],\n    timezone: strategy.suggestedSchedule?.timezone || 'UTC'\n  },\n  contentStructure: {\n    headline: strategy.contentStructure?.headline || '',\n    body: strategy.contentStructure?.body || '',\n    hashtags: Array.isArray(strategy.contentStructure?.hashtags) ? strategy.contentStructure.hashtags : [],\n    mentions: Array.isArray(strategy.contentStructure?.mentions) ? strategy.contentStructure.mentions : []\n  },\n  channels: Array.isArray(strategy.channels) ? strategy.channels : ($('Parse Analysis').item.json.channels || []),\n  tone: strategy.tone || 'profesional',\n  targetAudience: strategy.targetAudience || '',\n  keyPoints: Array.isArray(strategy.keyPoints) ? strategy.keyPoints : []\n};\n\nconst metadata = {\n  tenantId: $('Parse Analysis').item.json.tenantId || '',\n  generatedAt: new Date().toISOString(),\n  basedOnAnalysis: $('Parse Analysis').item.json.analysis || {},\n  basedOnMemory: $('Parse Analysis').item.json.memory || {}\n};\n\nreturn {\n  ...$('Parse Analysis').item.json,\n  strategy: { ...finalStrategy, metadata }\n};"
      },
      "id": "parse-strategy",
      "name": "Parse Strategy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2850, 500]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "create",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Eres un copywriter experto de marketing digital. Tu tarea es generar copy de marketing listo para publicar en redes sociales. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\n\n{\n  \"shortCopy\": \"string - copy corto (máximo 125 caracteres, ideal para stories o tweets)\",\n  \"longCopy\": \"string - copy largo (máximo 500 caracteres, ideal para posts)\",\n  \"hashtags\": [\"string\"],\n  \"variants\": {\n    \"variantA\": {\n      \"shortCopy\": \"string\",\n      \"longCopy\": \"string\",\n      \"hashtags\": [\"string\"]\n    },\n    \"variantB\": {\n      \"shortCopy\": \"string\",\n      \"longCopy\": \"string\",\n      \"hashtags\": [\"string\"]\n    }\n  },\n  \"headline\": \"string - título llamativo\",\n  \"cta\": \"string - call to action optimizado\",\n  \"emojiSuggestions\": [\"string\"],\n  \"mentions\": [\"string\"]\n}"
            },
            {
              "role": "user",
              "content": "={{ 'Genera copy de marketing listo para publicar basado en la siguiente estrategia, OPTIMIZANDO para canales con mejor performance histórico:\\n\\n## Estrategia:\\n' + JSON.stringify($json.strategy, null, 2) + '\\n\\n## Memoria Cognitiva Avanzada:\\n' + JSON.stringify({ learnedBestChannels: $json.learnedBestChannels || [], avoidPatterns: $json.avoidPatterns || [], confidenceWeights: $json.confidenceWeights || {}, performanceMemory: $json.advancedMemory?.performanceMemory || {} }, null, 2) + '\\n\\nConsidera y OPTIMIZA:\\n- El mensaje principal: ' + ($json.strategy.mainMessage || '') + '\\n- El CTA: ' + ($json.strategy.cta || '') + '\\n- El tono: ' + ($json.strategy.tone || 'profesional') + ' (prioriza tonos con mayor engagement histórico)\\n- El formato recomendado: ' + ($json.strategy.recommendedFormat || 'post') + '\\n- La audiencia objetivo: ' + ($json.strategy.targetAudience || '') + '\\n- Los puntos clave: ' + JSON.stringify($json.strategy.keyPoints || []) + '\\n- Los canales: ' + JSON.stringify($json.strategy.channels || []) + ' (prioriza canales con mejor CTR y engagement)\\n- EVITA patrones que han fallado históricamente\\n\\nResponde SOLO con el JSON del copy, sin texto adicional.' }}"
            }
          ]
        },
        "options": {
          "temperature": 0.8,
          "maxTokens": 1500
        },
        "authentication": "openAiApi"
      },
      "id": "openai-copy",
      "name": "OpenAI - Generate Copy",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [3050, 500],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI\nconst response = $input.item.json;\nlet copyData = {};\n\ntry {\n  let content = response.choices?.[0]?.message?.content || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  copyData = JSON.parse(content);\n} catch (error) {\n  try {\n    const jsonMatch = response.choices?.[0]?.message?.content?.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      copyData = JSON.parse(jsonMatch[0]);\n    } else {\n      const strategy = $('Parse Strategy').item.json.strategy || {};\n      copyData = {\n        shortCopy: strategy.mainMessage || 'Descubre más',\n        longCopy: (strategy.contentStructure?.body || strategy.mainMessage || '') + '\\n\\n' + (strategy.cta || ''),\n        hashtags: strategy.contentStructure?.hashtags || strategy.keyPoints || [],\n        variants: {\n          variantA: { shortCopy: strategy.mainMessage || 'Descubre más', longCopy: (strategy.contentStructure?.body || strategy.mainMessage || '') + '\\n\\n' + (strategy.cta || ''), hashtags: strategy.contentStructure?.hashtags || [] },\n          variantB: { shortCopy: strategy.mainMessage || 'Explora ahora', longCopy: (strategy.contentStructure?.body || strategy.mainMessage || '') + '\\n\\n' + (strategy.cta || ''), hashtags: strategy.contentStructure?.hashtags || [] }\n        },\n        headline: strategy.contentStructure?.headline || strategy.mainMessage || '',\n        cta: strategy.cta || 'Descubre más',\n        emojiSuggestions: [],\n        mentions: strategy.contentStructure?.mentions || []\n      };\n    }\n  } catch (parseError) {\n    const strategy = $('Parse Strategy').item.json.strategy || {};\n    copyData = {\n      shortCopy: 'Copy corto',\n      longCopy: 'Copy largo',\n      hashtags: [],\n      variants: { variantA: { shortCopy: '', longCopy: '', hashtags: [] }, variantB: { shortCopy: '', longCopy: '', hashtags: [] } },\n      headline: '',\n      cta: '',\n      emojiSuggestions: [],\n      mentions: []\n    };\n  }\n}\n\nconst finalCopy = {\n  shortCopy: copyData.shortCopy || 'Copy corto',\n  longCopy: copyData.longCopy || 'Copy largo',\n  hashtags: Array.isArray(copyData.hashtags) ? copyData.hashtags : [],\n  variants: {\n    variantA: {\n      shortCopy: copyData.variants?.variantA?.shortCopy || copyData.shortCopy || 'Variante A - Copy corto',\n      longCopy: copyData.variants?.variantA?.longCopy || copyData.longCopy || 'Variante A - Copy largo',\n      hashtags: Array.isArray(copyData.variants?.variantA?.hashtags) ? copyData.variants.variantA.hashtags : (copyData.hashtags || [])\n    },\n    variantB: {\n      shortCopy: copyData.variants?.variantB?.shortCopy || copyData.shortCopy || 'Variante B - Copy corto',\n      longCopy: copyData.variants?.variantB?.longCopy || copyData.longCopy || 'Variante B - Copy largo',\n      hashtags: Array.isArray(copyData.variants?.variantB?.hashtags) ? copyData.variants.variantB.hashtags : (copyData.hashtags || [])\n    }\n  },\n  headline: copyData.headline || '',\n  cta: copyData.cta || 'Descubre más',\n  emojiSuggestions: Array.isArray(copyData.emojiSuggestions) ? copyData.emojiSuggestions : [],\n  mentions: Array.isArray(copyData.mentions) ? copyData.mentions : []\n};\n\nconst strategy = $('Parse Strategy').item.json.strategy || {};\nconst publishReady = {\n  ...finalCopy,\n  publishFormat: {\n    instagram: {\n      caption: finalCopy.longCopy + '\\n\\n' + finalCopy.hashtags.map(h => '#' + h.replace(/^#/, '')).join(' '),\n      storyText: finalCopy.shortCopy,\n      hashtags: finalCopy.hashtags\n    },\n    facebook: {\n      post: finalCopy.longCopy,\n      hashtags: finalCopy.hashtags\n    },\n    twitter: {\n      tweet: finalCopy.shortCopy,\n      thread: finalCopy.longCopy,\n      hashtags: finalCopy.hashtags\n    }\n  },\n  metadata: {\n    tenantId: $('Parse Strategy').item.json.tenantId || '',\n    generatedAt: new Date().toISOString(),\n    format: strategy.recommendedFormat || 'post',\n    channels: strategy.channels || [],\n    tone: strategy.tone || 'profesional'\n  }\n};\n\nreturn {\n  ...$('Parse Strategy').item.json,\n  copy: publishReady\n};"
      },
      "id": "parse-copy",
      "name": "Parse Copy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3250, 500]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "create",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Eres un experto en generación de prompts para IA visual (DALL-E, Midjourney, Stable Diffusion). Tu tarea es crear prompts optimizados y detallados para generar imágenes y videos basados en el contexto de marketing. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\n\n{\n  \"imagePrompt\": \"string - prompt detallado y optimizado para generación de imágenes (mínimo 50 palabras, incluir estilo, composición, iluminación, colores, mood, detalles técnicos)\",\n  \"videoPrompt\": \"string - prompt detallado y optimizado para generación de videos (mínimo 50 palabras, incluir movimiento, escena, transiciones, estilo visual)\",\n  \"imageStyle\": \"string - estilo visual recomendado (realistic, artistic, minimalist, vibrant, etc.)\",\n  \"colorPalette\": [\"string\"],\n  \"mood\": \"string\",\n  \"aspectRatio\": \"string - formato recomendado (16:9, 1:1, 9:16, etc.)\",\n  \"technicalSpecs\": {\n    \"resolution\": \"string\",\n    \"quality\": \"string\",\n    \"lighting\": \"string\",\n    \"composition\": \"string\"\n  }\n}"
            },
            {
              "role": "user",
              "content": "={{ 'Genera prompts visuales optimizados para IA basados en el siguiente contexto, PRIORIZANDO estilos visuales con mejor performance:\\n\\n## Estrategia de Marketing:\\n' + JSON.stringify($json.strategy, null, 2) + '\\n\\n## Copy Generado:\\n' + JSON.stringify($json.copy, null, 2) + '\\n\\n## Memoria Cognitiva Avanzada:\\n' + JSON.stringify({ learnedBestChannels: $json.learnedBestChannels || [], avoidPatterns: $json.avoidPatterns || [], confidenceWeights: $json.confidenceWeights || {}, performanceMemory: $json.advancedMemory?.performanceMemory || {} }, null, 2) + '\\n\\n## Memoria Histórica:\\n' + JSON.stringify($json.memory, null, 2) + '\\n\\nConsidera y OPTIMIZA:\\n- El mensaje principal: ' + ($json.strategy.mainMessage || '') + '\\n- El tono: ' + ($json.strategy.tone || 'profesional') + ' (prioriza estilos visuales que funcionan mejor con este tono)\\n- La audiencia objetivo: ' + ($json.strategy.targetAudience || '') + '\\n- El formato recomendado: ' + ($json.strategy.recommendedFormat || 'post') + '\\n- Los canales: ' + JSON.stringify($json.strategy.channels || []) + ' (ajusta aspect ratio y estilo según mejor performance por canal)\\n- El copy generado para entender el contexto visual\\n- Las preferencias históricas del tenant\\n- EVITA estilos visuales que han fallado históricamente\\n\\nResponde SOLO con el JSON de los prompts visuales, sin texto adicional.' }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 1200
        },
        "authentication": "openAiApi"
      },
      "id": "openai-visual",
      "name": "OpenAI - Generate Visual Prompts",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [3450, 500],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI\nconst response = $input.item.json;\nlet visualPrompts = {};\n\ntry {\n  let content = response.choices?.[0]?.message?.content || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  visualPrompts = JSON.parse(content);\n} catch (error) {\n  try {\n    const jsonMatch = response.choices?.[0]?.message?.content?.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      visualPrompts = JSON.parse(jsonMatch[0]);\n    } else {\n      const strategy = $('Parse Copy').item.json.strategy || {};\n      const copy = $('Parse Copy').item.json.copy || {};\n      const mainMessage = strategy.mainMessage || copy.longCopy || 'Producto de marketing';\n      visualPrompts = {\n        imagePrompt: `High-quality marketing image: ${mainMessage}. Professional photography style, vibrant colors, modern composition, natural lighting, engaging and attractive visual, optimized for social media, ${strategy.tone || 'professional'} tone`,\n        videoPrompt: `Marketing video: ${mainMessage}. Smooth camera movements, dynamic transitions, professional cinematography, vibrant colors, engaging visual storytelling, ${strategy.tone || 'professional'} aesthetic, optimized for social media`,\n        imageStyle: strategy.tone === 'casual' ? 'vibrant' : 'professional',\n        colorPalette: ['vibrant', 'modern'],\n        mood: strategy.tone || 'professional',\n        aspectRatio: strategy.recommendedFormat === 'story' ? '9:16' : strategy.recommendedFormat === 'reel' ? '9:16' : '1:1',\n        technicalSpecs: { resolution: 'high', quality: 'professional', lighting: 'natural', composition: 'balanced' }\n      };\n    }\n  } catch (parseError) {\n    const strategy = $('Parse Copy').item.json.strategy || {};\n    visualPrompts = {\n      imagePrompt: 'High-quality marketing image, professional style, vibrant colors',\n      videoPrompt: 'Marketing video, professional cinematography, engaging visuals',\n      imageStyle: 'professional',\n      colorPalette: [],\n      mood: 'professional',\n      aspectRatio: '1:1',\n      technicalSpecs: { resolution: 'high', quality: 'professional', lighting: 'natural', composition: 'balanced' }\n    };\n  }\n}\n\nconst finalPrompts = {\n  imagePrompt: visualPrompts.imagePrompt || 'High-quality marketing image, professional style',\n  videoPrompt: visualPrompts.videoPrompt || 'Marketing video, professional cinematography',\n  imageStyle: visualPrompts.imageStyle || 'professional',\n  colorPalette: Array.isArray(visualPrompts.colorPalette) ? visualPrompts.colorPalette : [],\n  mood: visualPrompts.mood || 'professional',\n  aspectRatio: visualPrompts.aspectRatio || '1:1',\n  technicalSpecs: {\n    resolution: visualPrompts.technicalSpecs?.resolution || 'high',\n    quality: visualPrompts.technicalSpecs?.quality || 'professional',\n    lighting: visualPrompts.technicalSpecs?.lighting || 'natural',\n    composition: visualPrompts.technicalSpecs?.composition || 'balanced'\n  }\n};\n\nconst strategy = $('Parse Copy').item.json.strategy || {};\nconst metadata = {\n  tenantId: $('Parse Copy').item.json.tenantId || '',\n  generatedAt: new Date().toISOString(),\n  format: strategy.recommendedFormat || 'post',\n  channels: strategy.channels || [],\n  tone: strategy.tone || 'professional'\n};\n\nreturn {\n  ...$('Parse Copy').item.json,\n  visualPrompts: { ...finalPrompts, metadata }\n};"
      },
      "id": "parse-visual-prompts",
      "name": "Parse Visual Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3650, 500]
    },
    {
      "parameters": {
        "jsCode": "// Motor de Decisiones Cognitivo - Calcula confidenceScore y ajusta decisiones\nconst components = $input.item.json;\nconst strategy = components.strategy || {};\nconst copy = components.copy || {};\nconst visualPrompts = components.visualPrompts || {};\nconst advancedMemory = components.advancedMemory || {};\nconst confidenceWeights = components.confidenceWeights || {};\nconst analysis = components.analysis || {};\n\n// Calcular confidenceScore base (0-1)\nlet confidenceScore = 0.5; // Base\nlet decisionRationale = [];\nlet learningSources = [];\n\n// Factor 1: Canales con mejor performance (30%)\n// AUTO-AJUSTE: Penaliza canales con bajo rendimiento histórico y refuerza los exitosos\nconst selectedChannels = Array.isArray(strategy.channels) ? strategy.channels : [];\nconst performanceMemory = advancedMemory.performanceMemory || {};\nconst channelKPIs = performanceMemory.channelKPIs || {};\n\n// Ajustar confidenceWeights basado en resultados históricos\nconst adjustedChannelWeights = {};\nselectedChannels.forEach(channel => {\n  const baseWeight = confidenceWeights.channel?.[channel.toLowerCase()] || 0.5;\n  const kpi = channelKPIs[channel.toLowerCase()] || {};\n  const ctr = kpi.ctr || 0;\n  const engagement = kpi.engagement || 0;\n  \n  // Ajuste automático: refuerza si tiene buen CTR/engagement, penaliza si no\n  let adjustment = 0;\n  if (ctr > 0.02) adjustment += 0.1; // CTR > 2% es bueno\n  if (ctr < 0.005) adjustment -= 0.15; // CTR < 0.5% es malo\n  if (engagement > 0.05) adjustment += 0.1; // Engagement > 5% es bueno\n  if (engagement < 0.01) adjustment -= 0.15; // Engagement < 1% es malo\n  \n  adjustedChannelWeights[channel.toLowerCase()] = Math.max(0.1, Math.min(0.9, baseWeight + adjustment));\n});\n\nconst channelConfidence = selectedChannels.reduce((acc, channel) => {\n  const weight = adjustedChannelWeights[channel.toLowerCase()] || 0.5;\n  return acc + weight;\n}, 0) / Math.max(selectedChannels.length, 1);\nconfidenceScore += channelConfidence * 0.3;\nif (channelConfidence > 0.6) {\n  decisionRationale.push(`Canales seleccionados tienen alta performance histórica (${(channelConfidence * 100).toFixed(0)}%)`);\n  learningSources.push('PerformanceMemory');\n}\n\n// Factor 2: Formato apropiado para urgencia (20%)\nconst urgency = analysis.urgency || 'medium';\nconst format = strategy.recommendedFormat || 'post';\nconst formatKey = `${urgency}_${format}`;\nconst formatConfidence = confidenceWeights.format?.[formatKey] || confidenceWeights.format?.[format] || 0.5;\nconfidenceScore += formatConfidence * 0.2;\nif (formatConfidence > 0.6) {\n  decisionRationale.push(`Formato ${format} es exitoso para urgencia ${urgency} (${(formatConfidence * 100).toFixed(0)}%)`);\n  learningSources.push('PatternMemory');\n}\n\n// Factor 3: Tono con mayor engagement (20%)\nconst tone = strategy.tone || 'profesional';\nconst toneConfidence = confidenceWeights.tone?.[tone] || 0.5;\nconfidenceScore += toneConfidence * 0.2;\nif (toneConfidence > 0.6) {\n  decisionRationale.push(`Tono ${tone} tiene alto engagement histórico (${(toneConfidence * 100).toFixed(0)}%)`);\n  learningSources.push('PerformanceMemory');\n}\n\n// Factor 4: Evitar patrones fallidos (15%)\n// AUTO-AJUSTE: Penaliza automáticamente patrones fallidos y refuerza exitosos\nconst avoidPatterns = components.avoidPatterns || [];\nconst patternMemory = advancedMemory.patternMemory || {};\nconst successfulPatterns = patternMemory.successfulPatterns || [];\nconst blockedPatterns = patternMemory.blockedPatterns || [];\nlet patternViolations = 0;\nconst currentPattern = `${urgency}_${format}_${tone}`;\nconst isBlocked = blockedPatterns.some(blocked => currentPattern.includes(blocked) || blocked.includes(currentPattern));\n\nif (isBlocked) {\n  patternViolations = 1;\n  confidenceScore = 0; // Bloqueo total si está en lista de bloqueados\n  decisionRationale.push(`BLOQUEO: Patrón bloqueado temporalmente por fallos repetidos (30 días)`);\n  learningSources.push('PatternMemory');\n} else if (avoidPatterns.some(pattern => currentPattern.includes(pattern) || pattern.includes(currentPattern))) {\n  patternViolations = 1;\n  confidenceScore -= 0.2; // Penalización aumentada para patrones fallidos\n  decisionRationale.push(`ADVERTENCIA: Patrón similar a uno que ha fallado históricamente - PENALIZADO`);\n} else if (successfulPatterns.some(pattern => currentPattern.includes(pattern) || pattern.includes(currentPattern))) {\n  // Refuerzo para patrones exitosos\n  confidenceScore += 0.1;\n  decisionRationale.push(`Patrón identificado como exitoso históricamente - REFORZADO`);\n  learningSources.push('PatternMemory');\n} else {\n  confidenceScore += 0.05; // Patrón neutro\n  decisionRationale.push(`Patrón no está en lista de fallos históricos`);\n  learningSources.push('PatternMemory');\n}\n\n// Factor 5: Preferencias del tenant (10%)\nconst preferredFormats = components.preferredFormats || [];\nif (preferredFormats.includes(format)) {\n  confidenceScore += 0.1;\n  decisionRationale.push(`Formato ${format} está en preferencias del tenant`);\n  learningSources.push('PreferenceMemory');\n}\n\n// Factor 6: Restricciones cumplidas (5%)\nconst constraints = advancedMemory.constraintMemory?.restrictions || [];\nconst hasViolations = constraints.some(constraint => {\n  const channel = selectedChannels.find(c => constraint.toLowerCase().includes(c.toLowerCase()));\n  return channel !== undefined;\n});\nif (!hasViolations) {\n  confidenceScore += 0.05;\n  decisionRationale.push(`No se violan restricciones conocidas`);\n  learningSources.push('ConstraintMemory');\n} else {\n  confidenceScore -= 0.05;\n  decisionRationale.push(`ADVERTENCIA: Posible violación de restricciones`);\n}\n\n// Normalizar confidenceScore a 0-1\nconfidenceScore = Math.max(0, Math.min(1, confidenceScore));\n\n// Ajustar temperatura del modelo según confidence\n// Si confidence es bajo, usar temperatura más alta para más variación\n// Si confidence es alto, usar temperatura más baja para consistencia\nconst adaptiveTemperature = confidenceScore < 0.6 ? 0.8 : (confidenceScore > 0.8 ? 0.5 : 0.7);\n\n// Reducir variantes si confidence es bajo\nconst shouldReduceVariants = confidenceScore < 0.6;\n\n// Obtener cognitiveVersion REAL desde último MarketingPack o memoria\n// Se incrementa automáticamente cuando hay cambios significativos\nconst lastCognitiveVersion = components.lastCognitiveVersion || 1;\nlet cognitiveVersion = lastCognitiveVersion;\n\n// Si hay patrones fallidos recientes o cambios en priorización, incrementar versión\nconst recentFailedPatterns = patternMemory.failedPatterns || [];\nconst hasRecentFailures = recentFailedPatterns.length > 0;\nconst hasChannelPriorityChanges = performanceMemory.bestPerformingChannels && \n  performanceMemory.bestPerformingChannels.length > 0 &&\n  !selectedChannels.every(c => performanceMemory.bestPerformingChannels.includes(c));\n\n// Verificar si hay patrones exitosos nuevos que cambien priorización\nconst hasSuccessfulPatterns = successfulPatterns.length > 0 && \n  !successfulPatterns.every(sp => {\n    const patternStr = typeof sp === 'string' ? sp : (sp.pattern || JSON.stringify(sp));\n    return currentPattern.includes(patternStr) || patternStr.includes(currentPattern);\n  });

// Incrementar versión cuando hay aprendizaje significativo\nif (hasRecentFailures || hasChannelPriorityChanges || hasSuccessfulPatterns || patternViolations > 0) {\n  cognitiveVersion = lastCognitiveVersion + 1;\n}\n\n// Decision rationale completo\nconst fullRationale = decisionRationale.join('; ');\n\n// Learning sources únicos\nconst uniqueLearningSources = [...new Set(learningSources)];\n\nreturn {\n  ...components,\n  cognitiveDecision: {\n    confidenceScore: confidenceScore,\n    adaptiveTemperature: adaptiveTemperature,\n    shouldReduceVariants: shouldReduceVariants,\n    decisionRationale: fullRationale,\n    learningSources: uniqueLearningSources,\n    cognitiveVersion: cognitiveVersion,\n    channelConfidence: channelConfidence,\n    formatConfidence: formatConfidence,\n    toneConfidence: toneConfidence,\n    patternViolations: patternViolations,\n    calculatedAt: ($('Set Validated Data').item?.json?.validatedData?.receivedAt || new Date().toISOString())\n  }\n};"
      },
      "id": "cognitive-decision-engine",
      "name": "Cognitive Decision Engine",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3850, 500]
    },
    {
      "parameters": {
        "jsCode": "// Ensamblar el MarketingPack completo con campos cognitivos\nconst components = $input.item.json;\nconst strategy = components.strategy || {};\nconst copy = components.copy || {};\nconst visualPrompts = components.visualPrompts || {};\nconst media = Array.isArray(components.assets) ? components.assets : [];\nconst channels = Array.isArray(components.channels) ? components.channels : (strategy.channels || []);\n\n// Generar ID único para el pack\nconst packId = require('crypto').randomUUID ? require('crypto').randomUUID() : \n  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n\n// Construir la estrategia como texto estructurado\nconst strategyText = JSON.stringify({\n  mainMessage: strategy.mainMessage || '',\n  cta: strategy.cta || '',\n  recommendedFormat: strategy.recommendedFormat || 'post',\n  tone: strategy.tone || 'profesional',\n  targetAudience: strategy.targetAudience || '',\n  keyPoints: strategy.keyPoints || [],\n  suggestedSchedule: strategy.suggestedSchedule || {},\n  contentStructure: strategy.contentStructure || {}\n}, null, 2);\n\n// Construir metadatos completos\nconst metadata = {\n  tenantId: components.tenantId || '',\n  userId: components.userId || '',\n  campaignId: components.campaignId || null,\n  contentId: '',\n  channels: channels,\n  requiresApproval: components.requiresApproval !== undefined ? components.requiresApproval : true,\n  generatedAt: new Date().toISOString(),\n  version: 1,\n  strategy: strategy,\n  copy: copy,\n  visualPrompts: visualPrompts,\n  media: media\n};\n\n// Construir GeneratedCopies desde el copy\nconst generatedCopies = [];\n\nif (copy.longCopy) {\n  generatedCopies.push({\n    id: require('crypto').randomUUID ? require('crypto').randomUUID() : 'copy-' + Date.now(),\n    copyType: 'long',\n    content: copy.longCopy,\n    hashtags: copy.hashtags ? copy.hashtags.join(', ') : null,\n    suggestedChannel: channels.length > 0 ? channels[0] : null,\n    publicationChecklist: {\n      hasCopy: true,\n      hasHashtags: (copy.hashtags || []).length > 0,\n      hasMedia: media.length > 0,\n      readyForPublication: true\n    }\n  });\n}\n\nif (copy.shortCopy) {\n  generatedCopies.push({\n    id: require('crypto').randomUUID ? require('crypto').randomUUID() : 'copy-short-' + Date.now(),\n    copyType: 'short',\n    content: copy.shortCopy,\n    hashtags: copy.hashtags ? copy.hashtags.join(', ') : null,\n    suggestedChannel: channels.length > 0 ? channels[0] : null,\n    publicationChecklist: {\n      hasCopy: true,\n      hasHashtags: (copy.hashtags || []).length > 0,\n      hasMedia: media.length > 0,\n      readyForPublication: true\n    }\n  });\n}\n\nif (copy.variants) {\n  if (copy.variants.variantA) {\n    generatedCopies.push({\n      id: require('crypto').randomUUID ? require('crypto').randomUUID() : 'copy-var-a-' + Date.now(),\n      copyType: 'variant-a',\n      content: copy.variants.variantA.longCopy || copy.variants.variantA.shortCopy || '',\n      hashtags: copy.variants.variantA.hashtags ? copy.variants.variantA.hashtags.join(', ') : null,\n      suggestedChannel: channels.length > 0 ? channels[0] : null,\n      publicationChecklist: {\n        hasCopy: true,\n        hasHashtags: (copy.variants.variantA.hashtags || []).length > 0,\n        isVariant: true,\n        variantType: 'A'\n      }\n    });\n  }\n  \n  if (copy.variants.variantB) {\n    generatedCopies.push({\n      id: require('crypto').randomUUID ? require('crypto').randomUUID() : 'copy-var-b-' + Date.now(),\n      copyType: 'variant-b',\n      content: copy.variants.variantB.longCopy || copy.variants.variantB.shortCopy || '',\n      hashtags: copy.variants.variantB.hashtags ? copy.variants.variantB.hashtags.join(', ') : null,\n      suggestedChannel: channels.length > 0 ? channels[0] : null,\n      publicationChecklist: {\n        hasCopy: true,\n        hasHashtags: (copy.variants.variantB.hashtags || []).length > 0,\n        isVariant: true,\n        variantType: 'B'\n      }\n    });\n  }\n}\n\n// Construir MarketingAssetPrompts desde visualPrompts\nconst assetPrompts = [];\n\nif (visualPrompts.imagePrompt) {\n  assetPrompts.push({\n    id: require('crypto').randomUUID ? require('crypto').randomUUID() : 'prompt-img-' + Date.now(),\n    assetType: 'image',\n    prompt: visualPrompts.imagePrompt,\n    negativePrompt: null,\n    parameters: {\n      style: visualPrompts.imageStyle || 'professional',\n      aspectRatio: visualPrompts.aspectRatio || '1:1',\n      colorPalette: visualPrompts.colorPalette || [],\n      mood: visualPrompts.mood || 'professional',\n      ...(visualPrompts.technicalSpecs || {})\n    },\n    suggestedChannel: channels.length > 0 ? channels[0] : null\n  });\n}\n\nif (visualPrompts.videoPrompt) {\n  assetPrompts.push({\n    id: require('crypto').randomUUID ? require('crypto').randomUUID() : 'prompt-vid-' + Date.now(),\n    assetType: 'video',\n    prompt: visualPrompts.videoPrompt,\n    negativePrompt: null,\n    parameters: {\n      aspectRatio: visualPrompts.aspectRatio || '16:9',\n      colorPalette: visualPrompts.colorPalette || [],\n      mood: visualPrompts.mood || 'professional',\n      ...(visualPrompts.technicalSpecs || {})\n    },\n    suggestedChannel: channels.length > 0 ? channels[0] : null\n  });\n}\n\n// Obtener datos cognitivos del Decision Engine\nconst cognitiveDecision = components.cognitiveDecision || {};\nconst confidenceScore = cognitiveDecision.confidenceScore || 0.5;\nconst cognitiveVersion = cognitiveDecision.cognitiveVersion || 1;\nconst decisionRationale = cognitiveDecision.decisionRationale || '';\nconst learningSources = cognitiveDecision.learningSources || [];\n\n// Construir el MarketingPack final con campos cognitivos\nconst marketingPack = {\n  id: packId,\n  tenantId: components.tenantId || '',\n  userId: components.userId || '',\n  contentId: '',\n  campaignId: components.campaignId || null,\n  strategy: strategyText,\n  status: components.requiresApproval ? 'Generated' : 'Ready',\n  version: 1,\n  metadata: JSON.stringify(metadata),\n  copies: generatedCopies,\n  assetPrompts: assetPrompts,\n  channels: channels,\n  media: media,\n  requiresApproval: components.requiresApproval !== undefined ? components.requiresApproval : true,\n  createdAt: new Date().toISOString(),\n  // Campos cognitivos\n  cognitiveVersion: cognitiveVersion,\n  confidenceScore: confidenceScore,\n  learningSources: learningSources,\n  decisionRationale: decisionRationale\n};\n\nreturn {\n  ...components,\n  marketingPack: marketingPack,\n  cognitiveDecision: cognitiveDecision\n};"
      },
      "id": "build-pack",
      "name": "Build Marketing Pack",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3850, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.marketingPack.confidenceScore ?? $json.cognitiveDecision?.confidenceScore ?? 0.5 }}",
              "rightValue": 0.6,
              "operator": {
                "type": "number",
                "operation": "smaller"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validate-confidence-score",
      "name": "Validate Confidence Score",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4050, 500]
    },
    {
      "parameters": {
        "jsCode": "// Registrar Override Humano cuando confidenceScore < 0.6 pero requiresApproval = false\nconst components = $input.item.json;\nconst marketingPack = components.marketingPack || {};\nconst cognitiveDecision = components.cognitiveDecision || {};\nconst strategy = components.strategy || {};\nconst validatedData = $('Set Validated Data').item?.json?.validatedData || {};\n\nconst confidenceScore = marketingPack.confidenceScore ?? cognitiveDecision?.confidenceScore ?? 0.5;\nconst requiresApproval = marketingPack.requiresApproval ?? components.requiresApproval ?? true;\n\n// Detectar override: confidenceScore < 0.6 pero requiresApproval = false\nconst isOverride = confidenceScore < 0.6 && requiresApproval === false;\n\nif (isOverride) {\n  // Extraer datos del patrón\n  const urgency = components.analysis?.urgency || 'medium';\n  const format = strategy.recommendedFormat || 'post';\n  const tone = strategy.tone || 'profesional';\n  const channels = Array.isArray(strategy.channels) ? strategy.channels : [];\n  const pattern = `${urgency}_${format}_${tone}`;\n  \n  // Obtener overrideReason del payload si existe\n  const overrideReason = components.overrideReason || components.overrideSource || 'unknown';\n  const overrideSource = components.overrideSource || 'unknown';\n  \n  // Usar timestamp determinístico del validatedData\n  const timestamp = validatedData.receivedAt || new Date().toISOString();\n  const requestId = validatedData.requestId || 'unknown';\n  \n  // Crear overrideData estructurado\n  const overrideData = {\n    pattern: pattern,\n    result: 'override',\n    overrideType: 'human_forced_publication',\n    originalConfidenceScore: Math.round(confidenceScore * 10000) / 10000,\n    humanDecision: 'force_publication',\n    overrideReason: overrideReason,\n    overrideSource: overrideSource,\n    context: {\n      channels: channels,\n      format: format,\n      tone: tone,\n      urgency: urgency,\n      campaignId: components.campaignId || null,\n      marketingPackId: marketingPack.id || null\n    },\n    timestamp: timestamp,\n    requestId: requestId,\n    userId: components.userId || validatedData.userId || 'unknown',\n    decisionRationale: cognitiveDecision.decisionRationale || ''\n  };\n  \n  return {\n    ...components,\n    humanOverride: overrideData,\n    hasOverride: true\n  };\n}\n\n// Sin override, pasar datos sin cambios\nreturn {\n  ...components,\n  hasOverride: false\n};"
      },
      "id": "register-human-override",
      "name": "Register Human Override",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4250, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/save",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ $json.humanOverride ? { \"tenantId\": $json.tenantId, \"campaignId\": $json.campaignId, \"memoryType\": 'Pattern', \"content\": JSON.stringify($json.humanOverride), \"context\": $json.humanOverride.context, \"tags\": ['override', 'human-decision', 'pattern'], \"relevanceScore\": 9 } : {} }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-override-memory",
      "name": "HTTP Request - Save Override Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4450, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.marketingPack.confidenceScore ?? $json.cognitiveDecision?.confidenceScore ?? 0.5 }}",
              "rightValue": 0.6,
              "operator": {
                "type": "number",
                "operation": "smaller"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-approval-final",
      "name": "Check Requires Approval Final",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4250, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"id\": $json.marketingPack.id || null, \"tenantId\": $json.marketingPack.tenantId, \"userId\": $json.marketingPack.userId, \"contentId\": $json.marketingPack.contentId, \"campaignId\": $json.marketingPack.campaignId || null, \"strategy\": $json.marketingPack.strategy, \"status\": \"RequiresApproval\", \"version\": $json.marketingPack.version || 1, \"metadata\": $json.marketingPack.metadata, \"copies\": $json.marketingPack.copies || [], \"assetPrompts\": $json.marketingPack.assetPrompts || [], \"cognitiveVersion\": $json.marketingPack.cognitiveVersion || 1, \"confidenceScore\": $json.marketingPack.confidenceScore || 0.5, \"learningSources\": $json.marketingPack.learningSources || [], \"decisionRationale\": $json.marketingPack.decisionRationale || '' } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-pack-approval",
      "name": "HTTP Request - Save Pack (Requires Approval)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4250, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, message: 'Marketing pack sent for approval', data: { packId: $json.id || $('HTTP Request - Save Pack (Requires Approval)').item.json.id, status: 'RequiresApproval', requiresApproval: true, message: 'Pack has been saved and is waiting for human approval', nextStep: 'approval' } } }}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "respond-approval-required",
      "name": "Respond - Approval Required",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [4450, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"id\": $json.marketingPack.id || null, \"tenantId\": $json.marketingPack.tenantId, \"userId\": $json.marketingPack.userId, \"contentId\": $json.marketingPack.contentId, \"campaignId\": $json.marketingPack.campaignId || null, \"strategy\": $json.marketingPack.strategy, \"status\": \"Ready\", \"version\": $json.marketingPack.version || 1, \"metadata\": $json.marketingPack.metadata, \"copies\": $json.marketingPack.copies || [], \"assetPrompts\": $json.marketingPack.assetPrompts || [], \"cognitiveVersion\": $json.marketingPack.cognitiveVersion || 1, \"confidenceScore\": $json.marketingPack.confidenceScore || 0.5, \"learningSources\": $json.marketingPack.learningSources || [], \"decisionRationale\": $json.marketingPack.decisionRationale || '' } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-pack-ready",
      "name": "HTTP Request - Save Pack (Ready)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4250, 600]
    },
    {
      "parameters": {
        "jsCode": "// Preparar datos para publicación en cada canal\nconst marketingPack = $input.item.json.marketingPack;\nconst copy = $input.item.json.copy || {};\nconst channels = Array.isArray(marketingPack.channels) ? marketingPack.channels : [];\nconst publishJobs = [];\n\n// Para cada canal, crear un job de publicación\nchannels.forEach(channel => {\n  const channelCopy = copy.publishFormat?.[channel.toLowerCase()] || copy.longCopy || '';\n  const hashtags = copy.hashtags || [];\n  const hashtagsString = hashtags.map(h => '#' + h.replace(/^#/, '')).join(' ');\n  \n  publishJobs.push({\n    channel: channel.toLowerCase(),\n    content: channelCopy,\n    hashtags: hashtagsString,\n    mediaUrl: marketingPack.media && marketingPack.media.length > 0 ? marketingPack.media[0] : null,\n    tenantId: marketingPack.tenantId,\n    campaignId: marketingPack.campaignId,\n    marketingPackId: marketingPack.id,\n    generatedCopyId: marketingPack.copies && marketingPack.copies.length > 0 ? marketingPack.copies[0].id : null\n  });\n});\n\nreturn publishJobs.map(job => ({ json: { ...$input.item.json, ...job } }));"
      },
      "id": "prepare-publish-jobs",
      "name": "Prepare Publish Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4450, 600]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.channel.toLowerCase() }}",
              "rightValue": "instagram",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-instagram",
      "name": "Check - Instagram",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4650, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.channel.toLowerCase() }}",
              "rightValue": "facebook",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-facebook",
      "name": "Check - Facebook",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4650, 600]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.channel.toLowerCase() }}",
              "rightValue": "tiktok",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-tiktok",
      "name": "Check - TikTok",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4650, 700]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.INSTAGRAM_API_URL || 'https://api.instagram.com/v1/media' }}",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"caption\": ($json.content || '') + ' ' + ($json.hashtags || ''), \"image_url\": $json.mediaUrl || '', \"access_token\": $env.INSTAGRAM_ACCESS_TOKEN || 'simulated_token' } }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Publish-Data",
              "value": "={{ JSON.stringify({ channel: $json.channel, content: $json.content, hashtags: $json.hashtags, mediaUrl: $json.mediaUrl, tenantId: $json.tenantId, campaignId: $json.campaignId, marketingPackId: $json.marketingPackId, generatedCopyId: $json.generatedCopyId }) }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "publish-instagram",
      "name": "Publish - Instagram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4850, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.FACEBOOK_API_URL || 'https://graph.facebook.com/v18.0/me/feed' }}",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"message\": ($json.content || '') + ' ' + ($json.hashtags || ''), \"link\": $json.mediaUrl || '', \"access_token\": $env.FACEBOOK_ACCESS_TOKEN || 'simulated_token' } }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Publish-Data",
              "value": "={{ JSON.stringify({ channel: $json.channel, content: $json.content, hashtags: $json.hashtags, mediaUrl: $json.mediaUrl, tenantId: $json.tenantId, campaignId: $json.campaignId, marketingPackId: $json.marketingPackId, generatedCopyId: $json.generatedCopyId }) }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "publish-facebook",
      "name": "Publish - Facebook",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4850, 600]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.TIKTOK_API_URL || 'https://open-api.tiktok.com/video/upload' }}",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"caption\": ($json.content || '') + ' ' + ($json.hashtags || ''), \"video_url\": $json.mediaUrl || '', \"access_token\": $env.TIKTOK_ACCESS_TOKEN || 'simulated_token' } }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Publish-Data",
              "value": "={{ JSON.stringify({ channel: $json.channel, content: $json.content, hashtags: $json.hashtags, mediaUrl: $json.mediaUrl, tenantId: $json.tenantId, campaignId: $json.campaignId, marketingPackId: $json.marketingPackId, generatedCopyId: $json.generatedCopyId }) }}"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "publish-tiktok",
      "name": "Publish - TikTok",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4850, 700]
    },
    {
      "parameters": {
        "jsCode": "// Procesar resultado de publicación (real o simulado)\nconst input = $input.item.json;\n// Intentar obtener datos del item anterior usando el contexto de n8n\nlet publishData = {};\ntry {\n  // Intentar obtener del nodo anterior (Prepare Publish Jobs)\n  const previousNode = $('Prepare Publish Jobs');\n  if (previousNode && previousNode.item) {\n    publishData = previousNode.item.json;\n  }\n} catch (e) {\n  // Si falla, usar datos del input actual\n  publishData = input;\n}\n\n// Si el input tiene los datos directamente (viene de Check - Instagram/Facebook/TikTok cuando no coincide)\nconst channel = input.channel || publishData.channel || '';\nconst content = input.content || publishData.content || '';\nconst hashtags = input.hashtags || publishData.hashtags || '';\nconst mediaUrl = input.mediaUrl || publishData.mediaUrl || null;\nconst tenantId = input.tenantId || publishData.tenantId || '';\nconst campaignId = input.campaignId || publishData.campaignId || null;\nconst marketingPackId = input.marketingPackId || publishData.marketingPackId || null;\nconst generatedCopyId = input.generatedCopyId || publishData.generatedCopyId || null;\n\nconst isSimulated = !input.id && !input.post_id && !input.data && !input.success;\nconst hasError = input.error || input.error_code || (input.statusCode && input.statusCode >= 400);\n\nif (hasError || isSimulated) {\n  const simulatedResponse = {\n    success: true,\n    simulated: true,\n    channel: channel.toLowerCase(),\n    postId: `sim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    publishedUrl: `https://${channel.toLowerCase()}.com/posts/sim_${Date.now()}`,\n    publishedAt: new Date().toISOString(),\n    message: `Publication simulated for ${channel} (no credentials configured)`,\n    content: content,\n    hashtags: hashtags,\n    mediaUrl: mediaUrl,\n    tenantId: tenantId,\n    campaignId: campaignId,\n    marketingPackId: marketingPackId,\n    generatedCopyId: generatedCopyId\n  };\n  \n  return simulatedResponse;\n} else {\n  const realResponse = {\n    success: true,\n    simulated: false,\n    channel: channel.toLowerCase(),\n    postId: input.id || input.post_id || input.data?.id || `real_${Date.now()}`,\n    publishedUrl: input.permalink_url || input.link || input.data?.url || `https://${channel.toLowerCase()}.com/posts/${input.id || input.post_id}`,\n    publishedAt: new Date().toISOString(),\n    message: `Successfully published to ${channel}`,\n    content: content,\n    hashtags: hashtags,\n    mediaUrl: mediaUrl,\n    tenantId: tenantId,\n    campaignId: campaignId,\n    marketingPackId: marketingPackId,\n    generatedCopyId: generatedCopyId\n  };\n  \n  return realResponse;\n}"
      },
      "id": "process-publish-result",
      "name": "Process Publish Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5050, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/publishing-jobs",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"tenantId\": $json.tenantId, \"campaignId\": $json.campaignId, \"marketingPackId\": $json.marketingPackId || null, \"generatedCopyId\": $json.generatedCopyId || null, \"channel\": $json.channel, \"status\": $json.success ? 'Success' : 'Failed', \"publishedDate\": $json.publishedAt || new Date().toISOString(), \"publishedUrl\": $json.publishedUrl || null, \"externalPostId\": $json.postId || null, \"content\": $json.content, \"hashtags\": $json.hashtags, \"mediaUrl\": $json.mediaUrl || null, \"errorMessage\": $json.success ? null : ($json.error || $json.message || 'Unknown error'), \"metadata\": JSON.stringify({ \"simulated\": $json.simulated || false, \"channel\": $json.channel, \"publishedAt\": $json.publishedAt }), \"scheduledDate\": null } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-publishing-job",
      "name": "HTTP Request - Save Publishing Job",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [5250, 500]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar todos los resultados de publicación\nconst allResults = $input.all();\nconst firstResult = allResults[0] || {};\n\n// Obtener todos los publishing jobs guardados (vienen del HTTP Request - Save Publishing Job)\nconst publishingJobs = allResults\n  .filter(r => r.json.id && (r.json.channel || r.json.tenantId))\n  .map(r => ({\n    id: r.json.id,\n    channel: r.json.channel || 'unknown',\n    status: r.json.status || 'Success',\n    publishedUrl: r.json.publishedUrl || null\n  }));\n\n// Si no hay jobs, intentar obtener datos del primer resultado\nconst tenantId = firstResult.json.tenantId || '';\nconst campaignId = firstResult.json.campaignId || null;\nconst marketingPackId = firstResult.json.marketingPackId || null;\n\nreturn {\n  tenantId: tenantId,\n  campaignId: campaignId,\n  marketingPackId: marketingPackId,\n  publishingJobIds: publishingJobs.map(j => j.id).filter(id => id),\n  publishingJobs: publishingJobs,\n  channels: publishingJobs.map(j => j.channel).filter(c => c),\n  allPublished: publishingJobs.length > 0 && publishingJobs.every(j => j.status === 'Success'),\n  success: true\n};"
      },
      "id": "consolidate-publish-results",
      "name": "Consolidate Publish Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5450, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/metrics/campaign",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"tenantId\": $json.tenantId, \"campaignId\": $json.campaignId, \"metricDate\": new Date().toISOString().split('T')[0], \"impressions\": 0, \"clicks\": 0, \"likes\": 0, \"comments\": 0, \"shares\": 0, \"source\": 'n8n', \"notes\": 'Initial metrics from automated publishing' } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-campaign-metrics",
      "name": "HTTP Request - Save Campaign Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [5650, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/metrics/publishing-job",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"tenantId\": $json.tenantId, \"publishingJobId\": $json.publishingJobIds[0] || '', \"metricDate\": new Date().toISOString().split('T')[0], \"impressions\": 0, \"clicks\": 0, \"likes\": 0, \"comments\": 0, \"shares\": 0, \"source\": 'n8n', \"notes\": 'Initial metrics from automated publishing' } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-job-metrics",
      "name": "HTTP Request - Save Job Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [5650, 500]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar resultados finales\nconst results = $input.all();\nconst consolidateData = $('Consolidate Publish Results').item.json;\n\nconst metricsResult = results.find(r => r.json.id && r.json.campaignId) || null;\nconst jobMetricsResult = results.find(r => r.json.publishingJobId) || null;\n\nreturn {\n  tenantId: consolidateData.tenantId,\n  campaignId: consolidateData.campaignId,\n  marketingPackId: consolidateData.marketingPackId,\n  publishingJobIds: consolidateData.publishingJobIds,\n  publishingJobs: consolidateData.publishingJobs,\n  channels: consolidateData.channels,\n  metricsSaved: metricsResult !== null,\n  jobMetricsSaved: jobMetricsResult !== null,\n  metricsId: metricsResult?.json.id || null,\n  jobMetricsId: jobMetricsResult?.json.id || null,\n  success: true,\n  message: 'Complete marketing flow executed successfully'\n};"
      },
      "id": "consolidate-final-results",
      "name": "Consolidate Final Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5850, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, message: 'Complete marketing flow executed successfully', data: $json } }}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "respond-final-success",
      "name": "Respond - Final Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [6050, 500]
    }
  ],
  "connections": {
    "Webhook - Receive Request": {
      "main": [[{ "node": "Normalize Payload", "type": "main", "index": 0 }]]
    },
    "Normalize Payload": {
      "main": [[{ "node": "Validate Required Fields", "type": "main", "index": 0 }]]
    },
    "Validate Required Fields": {
      "main": [
        [{ "node": "Respond - Validation Error", "type": "main", "index": 0 }],
        [{ "node": "Set Validated Data", "type": "main", "index": 0 }]
      ]
    },
    "Set Validated Data": {
      "main": [[{ "node": "HTTP Request - Check Consents", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Check Consents": {
      "main": [[{ "node": "Normalize Consents", "type": "main", "index": 0 }]]
    },
    "Normalize Consents": {
      "main": [[{ "node": "Validate Consents", "type": "main", "index": 0 }]]
    },
    "Validate Consents": {
      "main": [
        [{ "node": "Respond - Consent Error", "type": "main", "index": 0 }],
        [{ "node": "HTTP Request - Load Marketing Memory", "type": "main", "index": 0 }]
      ]
    },
    "HTTP Request - Load Marketing Memory": {
      "main": [[{ "node": "Normalize Memory", "type": "main", "index": 0 }]]
    },
    "Normalize Memory": {
      "main": [
        [
          { "node": "HTTP Request - Load Preference Memory", "type": "main", "index": 0 },
          { "node": "HTTP Request - Load Performance Memory", "type": "main", "index": 0 },
          { "node": "HTTP Request - Load Constraint Memory", "type": "main", "index": 0 },
          { "node": "HTTP Request - Load Pattern Memory", "type": "main", "index": 0 },
          { "node": "HTTP Request - Get Last Cognitive Version", "type": "main", "index": 0 }
        ]
      ]
    },
    "HTTP Request - Load Preference Memory": {
      "main": [[{ "node": "Consolidate Advanced Memory", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Load Performance Memory": {
      "main": [[{ "node": "Consolidate Advanced Memory", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Load Constraint Memory": {
      "main": [[{ "node": "Consolidate Advanced Memory", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Load Pattern Memory": {
      "main": [[{ "node": "Consolidate Advanced Memory", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Get Last Cognitive Version": {
      "main": [[{ "node": "Consolidate Advanced Memory", "type": "main", "index": 0 }]]
    },
    "Consolidate Advanced Memory": {
      "main": [[{ "node": "OpenAI - Analyze Instruction (Cognitive)", "type": "main", "index": 0 }]]
    },
    "OpenAI - Analyze Instruction (Cognitive)": {
      "main": [[{ "node": "Parse Analysis", "type": "main", "index": 0 }]]
    },
    "Parse Analysis": {
      "main": [[{ "node": "OpenAI - Generate Strategy", "type": "main", "index": 0 }]]
    },
    "OpenAI - Generate Strategy": {
      "main": [[{ "node": "Parse Strategy", "type": "main", "index": 0 }]]
    },
    "Parse Strategy": {
      "main": [[{ "node": "OpenAI - Generate Copy", "type": "main", "index": 0 }]]
    },
    "OpenAI - Generate Copy": {
      "main": [[{ "node": "Parse Copy", "type": "main", "index": 0 }]]
    },
    "Parse Copy": {
      "main": [[{ "node": "OpenAI - Generate Visual Prompts", "type": "main", "index": 0 }]]
    },
    "OpenAI - Generate Visual Prompts": {
      "main": [[{ "node": "Parse Visual Prompts", "type": "main", "index": 0 }]]
    },
    "Parse Visual Prompts": {
      "main": [[{ "node": "Cognitive Decision Engine", "type": "main", "index": 0 }]]
    },
    "Cognitive Decision Engine": {
      "main": [[{ "node": "Build Marketing Pack", "type": "main", "index": 0 }]]
    },
    "Build Marketing Pack": {
      "main": [[{ "node": "Validate Confidence Score", "type": "main", "index": 0 }]]
    },
    "Validate Confidence Score": {
      "main": [
        [{ "node": "Register Human Override", "type": "main", "index": 0 }],
        [{ "node": "Check Requires Approval Final", "type": "main", "index": 0 }]
      ]
    },
    "Register Human Override": {
      "main": [
        [
          { "node": "HTTP Request - Save Override Memory", "type": "main", "index": 0 },
          { "node": "Check Requires Approval Final", "type": "main", "index": 0 }
        ]
      ]
    },
    "HTTP Request - Save Override Memory": {
      "main": [[{ "node": "Check Requires Approval Final", "type": "main", "index": 0 }]]
    },
    "Check Requires Approval Final": {
      "main": [
        [{ "node": "HTTP Request - Save Pack (Requires Approval)", "type": "main", "index": 0 }],
        [{ "node": "HTTP Request - Save Pack (Ready)", "type": "main", "index": 0 }]
      ]
    },
    "HTTP Request - Save Pack (Requires Approval)": {
      "main": [[{ "node": "Respond - Approval Required", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Save Pack (Ready)": {
      "main": [[{ "node": "Prepare Publish Jobs", "type": "main", "index": 0 }]]
    },
    "Prepare Publish Jobs": {
      "main": [
        [
          { "node": "Check - Instagram", "type": "main", "index": 0 },
          { "node": "Check - Facebook", "type": "main", "index": 0 },
          { "node": "Check - TikTok", "type": "main", "index": 0 }
        ]
      ]
    },
    "Check - Instagram": {
      "main": [
        [{ "node": "Publish - Instagram", "type": "main", "index": 0 }],
        [{ "node": "Process Publish Result", "type": "main", "index": 0 }]
      ]
    },
    "Check - Facebook": {
      "main": [
        [{ "node": "Publish - Facebook", "type": "main", "index": 0 }],
        [{ "node": "Process Publish Result", "type": "main", "index": 0 }]
      ]
    },
    "Check - TikTok": {
      "main": [
        [{ "node": "Publish - TikTok", "type": "main", "index": 0 }],
        [{ "node": "Process Publish Result", "type": "main", "index": 0 }]
      ]
    },
    "Publish - Instagram": {
      "main": [[{ "node": "Process Publish Result", "type": "main", "index": 0 }]]
    },
    "Publish - Facebook": {
      "main": [[{ "node": "Process Publish Result", "type": "main", "index": 0 }]]
    },
    "Publish - TikTok": {
      "main": [[{ "node": "Process Publish Result", "type": "main", "index": 0 }]]
    },
    "Process Publish Result": {
      "main": [[{ "node": "HTTP Request - Save Publishing Job", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Save Publishing Job": {
      "main": [[{ "node": "Consolidate Publish Results", "type": "main", "index": 0 }]]
    },
    "Consolidate Publish Results": {
      "main": [
        [{ "node": "HTTP Request - Save Campaign Metrics", "type": "main", "index": 0 }],
        [{ "node": "HTTP Request - Save Job Metrics", "type": "main", "index": 0 }],
        [{ "node": "HTTP Request - Save Learning", "type": "main", "index": 0 }]
      ]
    },
    "HTTP Request - Save Campaign Metrics": {
      "main": [[{ "node": "Consolidate Final Results", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Save Job Metrics": {
      "main": [[{ "node": "Consolidate Final Results", "type": "main", "index": 0 }]]
    },
    "Consolidate Final Results": {
      "main": [
        [{ "node": "Respond - Final Success", "type": "main", "index": 0 }]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-01T00:00:00.000Z",
      "updatedAt": "2025-01-01T00:00:00.000Z",
      "id": "marketing-automation",
      "name": "Marketing Automation"
    },
    {
      "createdAt": "2025-01-01T00:00:00.000Z",
      "updatedAt": "2025-01-01T00:00:00.000Z",
      "id": "complete-flow",
      "name": "Complete Flow"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "1"
}

