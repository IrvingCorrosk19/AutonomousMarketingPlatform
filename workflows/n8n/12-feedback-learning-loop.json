{
  "name": "Feedback Learning Loop - Post Publication",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 1
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Cron - Every Hour",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Buscar MarketingPacks publicados hace 24h y 48h\nconst now = new Date();\nconst hours24Ago = new Date(now.getTime() - 24 * 60 * 60 * 1000);\nconst hours48Ago = new Date(now.getTime() - 48 * 60 * 60 * 1000);\n\n// En producción, esto consultaría al backend para obtener packs publicados\n// Por ahora, simulamos que recibimos datos del trigger\nreturn [{\n  json: {\n    evaluationTime: '24h',\n    targetDate: hours24Ago.toISOString(),\n    now: now.toISOString()\n  }\n}, {\n  json: {\n    evaluationTime: '48h',\n    targetDate: hours48Ago.toISOString(),\n    now: now.toISOString()\n  }\n}];"
      },
      "id": "prepare-evaluation-times",
      "name": "Prepare Evaluation Times",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/publishing-jobs",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "publishedAfter",
              "value": "={{ $json.targetDate }}"
            },
            {
              "name": "status",
              "value": "Success"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-get-publishing-jobs",
      "name": "HTTP Request - Get Publishing Jobs",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "// Para cada publishing job, obtener métricas reales\nconst publishingJobs = Array.isArray($input.item.json) ? $input.item.json : [$input.item.json];\nconst evaluationTime = $('Prepare Evaluation Times').item.json.evaluationTime;\n\nconst jobsToEvaluate = publishingJobs\n  .filter(job => job.status === 'Success' && job.publishedDate)\n  .map(job => ({\n    json: {\n      publishingJobId: job.id,\n      campaignId: job.campaignId,\n      marketingPackId: job.marketingPackId,\n      channel: job.channel,\n      tenantId: job.tenantId,\n      publishedDate: job.publishedDate,\n      evaluationTime: evaluationTime\n    }\n  }));\n\nreturn jobsToEvaluate;"
      },
      "id": "prepare-jobs-for-evaluation",
      "name": "Prepare Jobs for Evaluation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/metrics/publishing-job",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "publishingJobId",
              "value": "={{ $json.publishingJobId }}"
            },
            {
              "name": "fromDate",
              "value": "={{ $json.publishedDate }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-get-job-metrics",
      "name": "HTTP Request - Get Job Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "id",
              "value": "={{ $json.marketingPackId }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-get-marketing-pack",
      "name": "HTTP Request - Get Marketing Pack",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $json.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Pattern"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-load-pattern-memory",
      "name": "HTTP Request - Load Pattern Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar métricas reales y datos del MarketingPack\n// COMPARACIÓN ESTRUCTURADA: Expectativa vs Realidad\nconst jobMetrics = $('HTTP Request - Get Job Metrics').item?.json || {};\nconst marketingPack = $('HTTP Request - Get Marketing Pack').item?.json || {};\nconst patternMemoryResponse = $('HTTP Request - Load Pattern Memory').item?.json || {}; // FASE 3: Cargar Pattern Memory\nconst jobData = $('Prepare Jobs for Evaluation').item.json;\n\n// Calcular métricas agregadas\nconst metrics = Array.isArray(jobMetrics) ? jobMetrics : [jobMetrics];\nconst totalImpressions = metrics.reduce((sum, m) => sum + (m.impressions || 0), 0);\nconst totalClicks = metrics.reduce((sum, m) => sum + (m.clicks || 0), 0);\nconst totalLikes = metrics.reduce((sum, m) => sum + (m.likes || 0), 0);\nconst totalComments = metrics.reduce((sum, m) => sum + (m.comments || 0), 0);\nconst totalShares = metrics.reduce((sum, m) => sum + (m.shares || 0), 0);\nconst totalEngagement = totalLikes + totalComments + totalShares;\n\n// Calcular KPIs REALES\nconst realCTR = totalImpressions > 0 ? (totalClicks / totalImpressions) : 0;\nconst realEngagementRate = totalImpressions > 0 ? (totalEngagement / totalImpressions) : 0;\nconst realReach = totalImpressions; // Alcance aproximado\n\n// Obtener confidenceScore y expectativas originales del MarketingPack\nconst packMetadata = marketingPack.metadata ? JSON.parse(marketingPack.metadata) : {};\nconst originalConfidenceScore = marketingPack.confidenceScore || packMetadata.cognitiveDecision?.confidenceScore || 0.5;\nconst originalCognitiveVersion = marketingPack.cognitiveVersion || 1;\n\n// Calcular expectativas basadas en confidenceScore\n// Si confidenceScore es alto, esperamos mejor rendimiento\nconst expectedCTR = originalConfidenceScore * 0.02; // 2% máximo esperado\nconst expectedEngagementRate = originalConfidenceScore * 0.05; // 5% máximo esperado\n\n// COMPARACIÓN ESTRUCTURADA: Expectativa vs Realidad\nconst ctrComparison = realCTR - expectedCTR;\nconst engagementComparison = realEngagementRate - expectedEngagementRate;\n\n// Determinar si el resultado fue positivo o negativo\n// Criterios: CTR > expectativa Y Engagement > expectativa = positivo\nconst isPositiveResult = ctrComparison > -0.005 && engagementComparison > -0.01; // Tolerancia pequeña\nconst result = isPositiveResult ? 'positive' : 'negative';\n\n// Extraer decisiones originales del pack\nconst strategy = packMetadata.strategy || {};\nconst format = strategy.recommendedFormat || 'post';\nconst tone = strategy.tone || 'profesional';\nconst channels = Array.isArray(strategy.channels) ? strategy.channels : [jobData.channel];\n\n// Comparar resultado vs confidenceScore original\nconst confidenceAccuracy = Math.abs(originalConfidenceScore - (isPositiveResult ? 0.8 : 0.3));\nconst wasAccurate = confidenceAccuracy < 0.3; // Si la diferencia es < 30%, fue preciso\n\nreturn {\n  ...jobData,\n  metrics: {\n    impressions: totalImpressions,\n    clicks: totalClicks,\n    likes: totalLikes,\n    comments: totalComments,\n    shares: totalShares,\n    engagement: totalEngagement,\n    ctr: realCTR,\n    engagementRate: realEngagementRate,\n    reach: realReach || totalImpressions\n  },\n  expectedMetrics: {\n    ctr: expectedCTR,\n    engagementRate: expectedEngagementRate\n  },\n  comparison: {\n    ctrDifference: ctrComparison,\n    engagementDifference: engagementComparison\n  },\n  originalDecision: {\n    confidenceScore: originalConfidenceScore,\n    cognitiveVersion: originalCognitiveVersion,\n    format: format,\n    tone: tone,\n    channels: channels\n  },\n  result: result,\n  isPositiveResult: isPositiveResult,\n  wasAccurate: wasAccurate,\n  confidenceAccuracy: confidenceAccuracy,\n  evaluationTime: jobData.evaluationTime,\n  patternMemory: patternMemoryResponse // FASE 3: Pasar Pattern Memory\n};"
      },
      "id": "consolidate-metrics",
      "name": "Consolidate Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "jsCode": "// FASE 3: Calcular Penalización Escalada según desvíos CTR/Engagement\nconst consolidatedData = $('Consolidate Metrics').item.json;\nconst realCTR = consolidatedData.metrics.ctr || 0;\nconst expectedCTR = consolidatedData.expectedMetrics.ctr || 0.01;\nconst realEngagement = consolidatedData.metrics.engagementRate || 0;\nconst expectedEngagement = consolidatedData.expectedMetrics.engagementRate || 0.02;\n\n// Obtener failureCount del patrón si existe\nconst patternMemoryResponse = $('HTTP Request - Load Pattern Memory')?.item?.json || {};\nconst patternMemories = Array.isArray(patternMemoryResponse) ? patternMemoryResponse : (patternMemoryResponse.data ? patternMemoryResponse.data : []);\nconst currentPattern = `${consolidatedData.originalDecision.format}_${consolidatedData.originalDecision.tone}_${consolidatedData.channel}`;\n\n// Contar fallos previos del patrón\nlet failureCount = 0;\npatternMemories.forEach(memory => {\n  try {\n    const content = typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n    const pattern = content.pattern || JSON.stringify(content);\n    if ((content.result === 'negative' || (content.penalty && content.penalty < 0)) && \n        (pattern === currentPattern || currentPattern.includes(pattern) || pattern.includes(currentPattern))) {\n      failureCount++;\n    }\n  } catch (e) {\n    // Ignorar errores\n  }\n});\n\n// Validar inputs (determinístico)\nconst safeRealCTR = realCTR ?? 0;\nconst safeExpectedCTR = expectedCTR ?? 0.01;\nconst safeRealEngagement = realEngagement ?? 0;\nconst safeExpectedEngagement = expectedEngagement ?? 0.02;\n\n// Evitar división por cero\nconst finalExpectedCTR = safeExpectedCTR === 0 ? 0.01 : safeExpectedCTR;\nconst finalExpectedEngagement = safeExpectedEngagement === 0 ? 0.02 : safeExpectedEngagement;\n\n// Calcular desvíos porcentuales (determinístico, redondeado a 4 decimales)\nconst ctrDeviation = Math.round((safeRealCTR / finalExpectedCTR) * 10000) / 10000;\nconst engagementDeviation = Math.round((safeRealEngagement / finalExpectedEngagement) * 10000) / 10000;\n\n// Usar el peor desvío (determinístico)\nconst worstDeviation = Math.min(ctrDeviation, engagementDeviation);\n\n// Calcular penalización escalada según severity\nlet penalty = 0;\nlet severity = 'none';\n\nif (worstDeviation >= 0.95) {\n  // Resultado positivo o neutro\n  penalty = Math.round(0 * 10000) / 10000;\n  severity = 'positive';\n} else if (worstDeviation >= 0.8) {\n  // Leve: -0.05 a -0.1\n  penalty = Math.round((-0.05 - ((0.95 - worstDeviation) * 0.05 / 0.15)) * 10000) / 10000;\n  severity = 'mild';\n} else if (worstDeviation >= 0.5) {\n  // Moderado: -0.15 a -0.25\n  penalty = Math.round((-0.15 - ((0.8 - worstDeviation) * 0.1 / 0.3)) * 10000) / 10000;\n  severity = 'moderate';\n} else if (worstDeviation >= 0.2) {\n  // Severo: -0.3 a -0.5\n  penalty = Math.round((-0.3 - ((0.5 - worstDeviation) * 0.2 / 0.3)) * 10000) / 10000;\n  severity = 'severe';\n} else {\n  // Crítico: -0.6 a -1.0\n  penalty = Math.round((-0.6 - ((0.2 - worstDeviation) * 0.4 / 0.2)) * 10000) / 10000;\n  severity = 'critical';\n}\n\n// Ajuste por fallos repetidos\nif (failureCount >= 3) {\n  penalty = Math.round(Math.min(penalty - 0.2, -1.0) * 10000) / 10000;\n  severity = 'critical';\n}\n\n// Si es resultado positivo, usar refuerzo\nif (consolidatedData.result === 'positive') {\n  penalty = Math.round(0.1 * 10000) / 10000;\n  severity = 'positive';\n}\n\nreturn {\n  ...consolidatedData,\n  escalatedPenalty: {\n    penalty: penalty,\n    severity: severity,\n    worstDeviation: worstDeviation,\n    ctrDeviation: ctrDeviation,\n    engagementDeviation: engagementDeviation,\n    failureCount: failureCount\n  }\n};"
      },
      "id": "calculate-escalated-penalty",
      "name": "Calculate Escalated Penalty",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "// FASE 3: Calcular Estado de Bloqueo Escalado\nconst dataWithPenalty = $('Calculate Escalated Penalty').item.json;\nconst escalatedPenalty = dataWithPenalty.escalatedPenalty || {};\nconst severity = escalatedPenalty.severity || 'none';\nconst failureCount = escalatedPenalty.failureCount || 0;\n\n// Obtener historial de fallos del patrón\nconst patternMemoryResponse = $('HTTP Request - Load Pattern Memory')?.item?.json || {};\nconst patternMemories = Array.isArray(patternMemoryResponse) ? patternMemoryResponse : (patternMemoryResponse.data ? patternMemoryResponse.data : []);\nconst currentPattern = `${dataWithPenalty.originalDecision.format}_${dataWithPenalty.originalDecision.tone}_${dataWithPenalty.channel}`;\n\n// Función determinística para calcular días desde timestamp\nfunction daysSinceTimestamp(timestamp, referenceTimestamp) {\n  if (!timestamp || !referenceTimestamp) return 999;\n  try {\n    const ts = new Date(timestamp).getTime();\n    const ref = new Date(referenceTimestamp).getTime();\n    if (isNaN(ts) || isNaN(ref)) return 999;\n    return Math.round(((ref - ts) / (1000 * 60 * 60 * 24)) * 10000) / 10000;\n  } catch (e) {\n    return 999;\n  }\n}\n\n// Obtener timestamp de referencia (del evento evaluado)\nconst referenceTimestamp = dataWithPenalty.originalDecision.timestamp || dataWithPenalty.evaluationTime || new Date().toISOString();\n\n// Contar fallos por severidad\nconst patternFailures = [];\npatternMemories.forEach(memory => {\n  try {\n    const content = typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n    const pattern = content.pattern || JSON.stringify(content);\n    if ((content.result === 'negative' || (content.penalty && content.penalty < 0) || content.result === 'override_result') &&\n        (pattern === currentPattern || currentPattern.includes(pattern) || pattern.includes(currentPattern))) {\n      const memoryTimestamp = content.timestamp || content.context?.evaluationTime || referenceTimestamp;\n      patternFailures.push({\n        severity: content.severity || 'moderate',\n        timestamp: memoryTimestamp,\n        daysSinceFailure: daysSinceTimestamp(memoryTimestamp, referenceTimestamp)\n      });\n    }\n  } catch (e) {\n    // Ignorar errores\n  }\n});\n\n// Ordenar por timestamp ASC (determinístico)\npatternFailures.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n\n// Contar por severidad\nconst severeCount = patternFailures.filter(p => p.severity === 'severe').length;\nconst criticalCount = patternFailures.filter(p => p.severity === 'critical').length;\nconst moderateCount = patternFailures.filter(p => p.severity === 'moderate').length;\n\n// Calcular estado de bloqueo escalado\nlet blockStatus = { status: 'none', duration: null, daysRemaining: null, requiresManualUnlock: false, minConfidence: null };\n\n// Bloqueo permanente\nif (criticalCount >= 5 || severeCount >= 10) {\n  blockStatus = {\n    status: 'permanent_block',\n    duration: null,\n    daysRemaining: null,\n    requiresManualUnlock: true,\n    minConfidence: null\n  };\n}\n// Bloqueo parcial (30 días)\nelse if (severeCount >= 3 || moderateCount >= 5) {\n  const lastFailure = patternFailures[patternFailures.length - 1];\n  const daysSinceFailure = lastFailure ? lastFailure.daysSinceFailure : 999;\n  \n  if (daysSinceFailure < 30) {\n    blockStatus = {\n      status: 'partial_block',\n      duration: 30,\n      daysRemaining: Math.round((30 - daysSinceFailure) * 10000) / 10000,\n      requiresManualUnlock: false,\n      minConfidence: null\n    };\n  }\n}\n// Restricción (7 días)\nelse if (severeCount >= 2 || moderateCount >= 3) {\n  const lastFailure = patternFailures[patternFailures.length - 1];\n  const daysSinceFailure = lastFailure ? lastFailure.daysSinceFailure : 999;\n  \n  if (daysSinceFailure < 7) {\n    blockStatus = {\n      status: 'restriction',\n      duration: 7,\n      daysRemaining: Math.round((7 - daysSinceFailure) * 10000) / 10000,\n      requiresManualUnlock: false,\n      minConfidence: 0.7\n    };\n  }\n}\n// Advertencia\nelse if (severeCount >= 1 || moderateCount >= 2) {\n  blockStatus = {\n    status: 'warning',\n    duration: null,\n    daysRemaining: null,\n    requiresManualUnlock: false,\n    minConfidence: null,\n    penalty: Math.round(-0.1 * 10000) / 10000\n  };\n}\n\nreturn {\n  ...dataWithPenalty,\n  blockStatus: blockStatus\n};"
      },
      "id": "calculate-block-status",
      "name": "Calculate Block Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "jsCode": "// FASE 3: Verificar Resultado de Override Humano\nconst dataWithBlock = $('Calculate Block Status').item.json;\nconst currentPattern = `${dataWithBlock.originalDecision.format}_${dataWithBlock.originalDecision.tone}_${dataWithBlock.channel}`;\n\n// Buscar override previo para este patrón\nconst patternMemoryResponse = $('HTTP Request - Load Pattern Memory')?.item?.json || {};\nconst patternMemories = Array.isArray(patternMemoryResponse) ? patternMemoryResponse : (patternMemoryResponse.data ? patternMemoryResponse.data : []);\n\nlet overrideMemory = null;\npatternMemories.forEach(memory => {\n  try {\n    const content = typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n    if (content.result === 'override' && content.overrideType === 'human_forced_publication') {\n      const pattern = content.pattern || JSON.stringify(content);\n      if (pattern === currentPattern || currentPattern.includes(pattern) || pattern.includes(pattern)) {\n        overrideMemory = content;\n      }\n    }\n  } catch (e) {\n    // Ignorar errores\n  }\n});\n\nlet overrideResult = null;\nlet overridePenalty = 0;\n\nif (overrideMemory) {\n  // Evaluar resultado del override\n  const isPositive = dataWithBlock.result === 'positive';\n  const originalConfidenceScore = overrideMemory.originalConfidenceScore || 0.5;\n  \n  if (isPositive) {\n    // Override exitoso: reforzar patrón\n    overrideResult = 'positive';\n    overridePenalty = Math.round(0.2 * 10000) / 10000; // Refuerzo positivo\n  } else {\n    // Override fallido: penalizar severamente (humano ignoró advertencia)\n    overrideResult = 'negative';\n    overridePenalty = Math.round(-0.4 * 10000) / 10000; // Penalización severa\n    \n    // Si el override fue crítico (muy bajo confidence), penalizar aún más\n    if (originalConfidenceScore < 0.4) {\n      overridePenalty = Math.round(-0.6 * 10000) / 10000; // Penalización crítica\n    }\n  }\n}\n\nreturn {\n  ...dataWithBlock,\n  overrideResult: {\n    hasOverride: overrideMemory !== null,\n    overrideMemory: overrideMemory,\n    overrideResult: overrideResult,\n    overridePenalty: overridePenalty\n  }\n};"
      },
      "id": "check-override-result",
      "name": "Check Override Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "create",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "Eres un analista experto de marketing que evalúa resultados de campañas. Tu tarea es generar un EvaluationSummary estructurado. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\n\n{\n  \"summary\": \"string - resumen ejecutivo de los resultados\",\n  \"performance\": \"string - evaluación de performance (excellent, good, average, poor)\",\n  \"keyInsights\": [\"string\"],\n  \"recommendations\": [\"string\"],\n  \"patternAnalysis\": {\n    \"pattern\": \"string - patrón identificado (ej: medium_post_profesional_instagram)\",\n    \"result\": \"string - positive o negative\",\n    \"penalty\": number - penalización si fue negativo (0-1), refuerzo si fue positivo (0-1)\n  },\n  \"channelPerformance\": {\n    \"channel\": \"string\",\n    \"ctr\": number,\n    \"engagementRate\": number,\n    \"performance\": \"string\"\n  },\n  \"shouldIncrementVersion\": boolean - true si se debe incrementar cognitiveVersion\n}"
            },
            {
              "role": "user",
              "content": "={{ 'Evalúa los siguientes resultados de campaña y genera un EvaluationSummary:\\n\\n## Métricas Reales:\\n' + JSON.stringify($json.metrics, null, 2) + '\\n\\n## Decisión Original:\\n' + JSON.stringify($json.originalDecision, null, 2) + '\\n\\n## Resultado:\\n- Resultado: ' + $json.result + '\\n- Fue preciso: ' + $json.wasAccurate + '\\n- Accuracy: ' + (typeof $json.confidenceAccuracy === 'number' ? $json.confidenceAccuracy.toFixed(2) : '0.00') + '\\n\\n## Contexto:\\n- Canal: ' + $json.channel + '\\n- Formato: ' + $json.originalDecision.format + '\\n- Tono: ' + $json.originalDecision.tone + '\\n- Tiempo de evaluación: ' + $json.evaluationTime + '\\n\\nResponde SOLO con el JSON del EvaluationSummary, sin texto adicional.' }}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 1000
        },
        "authentication": "openAiApi"
      },
      "id": "openai-evaluation-summary",
      "name": "OpenAI - Generate Evaluation Summary",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [2050, 300],
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear EvaluationSummary y preparar aprendizajes estructurados\n// FASE 3: Incluir severity, blockStatus y overrideResult\nconst response = $input.item.json;\nconst dataWithOverride = $('Check Override Result').item.json;\nconst escalatedPenalty = dataWithOverride.escalatedPenalty || {};\nconst blockStatus = dataWithOverride.blockStatus || {};\nconst overrideResult = dataWithOverride.overrideResult || {};\nconst consolidatedData = $('Consolidate Metrics').item.json;\n\nlet evaluationSummary = {};\ntry {\n  let content = response.choices?.[0]?.message?.content || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  evaluationSummary = JSON.parse(content);\n} catch (error) {\n  // Fallback\n  const pattern = `${consolidatedData.originalDecision.format}_${consolidatedData.originalDecision.tone}_${consolidatedData.channel}`;\n  evaluationSummary = {\n    summary: `Resultado ${consolidatedData.result} para campaña`,\n    performance: consolidatedData.isPositiveResult ? 'good' : 'poor',\n    keyInsights: [consolidatedData.isPositiveResult ? 'Campaña exitosa' : 'Campaña con bajo rendimiento'],\n    recommendations: [],\n    patternAnalysis: {\n      pattern: pattern,\n      result: consolidatedData.result,\n      penalty: consolidatedData.isPositiveResult ? 0.1 : -0.2\n    },\n    channelPerformance: {\n      channel: consolidatedData.channel,\n      ctr: consolidatedData.metrics.ctr,\n      engagementRate: consolidatedData.metrics.engagementRate,\n      performance: consolidatedData.isPositiveResult ? 'good' : 'poor'\n    },\n    shouldIncrementVersion: !consolidatedData.wasAccurate || (!consolidatedData.isPositiveResult && consolidatedData.originalDecision.confidenceScore < 0.6)\n  };\n}\n\n// Preparar aprendizajes estructurados\nconst learnings = {\n  performanceMemory: {\n    memoryType: 'Learning',\n    content: {\n      channel: consolidatedData.channel,\n      format: consolidatedData.originalDecision.format,\n      tone: consolidatedData.originalDecision.tone,\n      metrics: consolidatedData.metrics,\n      result: consolidatedData.result,\n      evaluationTime: consolidatedData.evaluationTime,\n      originalConfidenceScore: consolidatedData.originalDecision.confidenceScore\n    },\n    context: {\n      campaignId: consolidatedData.campaignId,\n      marketingPackId: consolidatedData.marketingPackId,\n      publishingJobId: consolidatedData.publishingJobId,\n      cognitiveVersion: consolidatedData.originalDecision.cognitiveVersion\n    },\n    relevanceScore: consolidatedData.isPositiveResult ? 9 : 7\n  },\n  patternMemory: {\n    memoryType: 'Pattern',\n    content: {\n      pattern: evaluationSummary.patternAnalysis?.pattern || `${consolidatedData.originalDecision.format}_${consolidatedData.originalDecision.tone}_${consolidatedData.channel}`,\n      result: overrideResult.hasOverride ? 'override_result' : (evaluationSummary.patternAnalysis?.result || consolidatedData.result),\n      penalty: overrideResult.hasOverride ? overrideResult.overridePenalty : (escalatedPenalty.penalty || evaluationSummary.patternAnalysis?.penalty || (consolidatedData.isPositiveResult ? 0.1 : -0.2)),\n      severity: escalatedPenalty.severity || 'moderate',\n      blockStatus: blockStatus.status || 'none',\n      failureCount: escalatedPenalty.failureCount || 0,\n      metrics: consolidatedData.metrics,\n      wasAccurate: consolidatedData.wasAccurate,\n      overrideResult: overrideResult.hasOverride ? overrideResult.overrideResult : null,\n      timestamp: consolidatedData.evaluationTime || (consolidatedData.originalDecision?.timestamp || new Date().toISOString())\n    },\n    context: {\n      campaignId: consolidatedData.campaignId,\n      marketingPackId: consolidatedData.marketingPackId,\n      evaluationTime: consolidatedData.evaluationTime,\n      originalConfidenceScore: consolidatedData.originalDecision.confidenceScore\n    },\n    relevanceScore: 8\n  },\n  shouldIncrementVersion: evaluationSummary.shouldIncrementVersion || (!consolidatedData.wasAccurate || (!consolidatedData.isPositiveResult && consolidatedData.originalDecision.confidenceScore < 0.6))\n};\n\nreturn {\n  ...consolidatedData,\n  evaluationSummary: evaluationSummary,\n  learnings: learnings\n};"
      },
      "id": "prepare-structured-learnings",
      "name": "Prepare Structured Learnings",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/save",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"tenantId\": $json.tenantId, \"campaignId\": $json.campaignId, \"memoryType\": $json.learnings.performanceMemory.memoryType, \"content\": JSON.stringify($json.learnings.performanceMemory.content), \"context\": $json.learnings.performanceMemory.context, \"tags\": ['performance', 'metrics', $json.channel, $json.evaluationTime], \"relevanceScore\": $json.learnings.performanceMemory.relevanceScore } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-performance-memory",
      "name": "HTTP Request - Save Performance Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/save",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"tenantId\": $json.tenantId, \"campaignId\": $json.campaignId, \"memoryType\": $json.learnings.patternMemory.memoryType, \"content\": JSON.stringify($json.learnings.patternMemory.content), \"context\": $json.learnings.patternMemory.context, \"tags\": ['pattern', $json.result, $json.channel, $json.evaluationTime], \"relevanceScore\": $json.learnings.patternMemory.relevanceScore } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-pattern-memory",
      "name": "HTTP Request - Save Pattern Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.learnings.shouldIncrementVersion }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-increment-version",
      "name": "Check - Increment Version",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1850, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/memory/save",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ { \"tenantId\": $json.tenantId, \"campaignId\": $json.campaignId, \"memoryType\": 'Pattern', \"content\": JSON.stringify({ type: 'cognitive_version_increment', reason: $json.evaluationSummary.summary || 'Learning from campaign results', previousVersion: $json.originalDecision.cognitiveVersion, newVersion: $json.originalDecision.cognitiveVersion + 1, trigger: $json.learnings.shouldIncrementVersion ? 'automatic' : 'manual' }), \"context\": { marketingPackId: $json.marketingPackId, evaluationTime: $json.evaluationTime, result: $json.result }, \"tags\": ['cognitive-version', 'evolution'], \"relevanceScore\": 10 } }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "http-save-version-increment",
      "name": "HTTP Request - Save Version Increment",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2050, 500]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar resultados del aprendizaje\nconst results = $input.all();\nconst learningData = $('Prepare Structured Learnings').item.json;\n\nconst performanceSaved = results.find(r => r.json.id && r.json.memoryType === 'Learning') || null;\nconst patternSaved = results.find(r => r.json.id && r.json.memoryType === 'Pattern' && r.json.tags?.includes('pattern')) || null;\nconst versionSaved = results.find(r => r.json.id && r.json.tags?.includes('cognitive-version')) || null;\n\nreturn {\n  tenantId: learningData.tenantId,\n  campaignId: learningData.campaignId,\n  marketingPackId: learningData.marketingPackId,\n  publishingJobId: learningData.publishingJobId,\n  evaluationTime: learningData.evaluationTime,\n  result: learningData.result,\n  performanceMemorySaved: performanceSaved !== null,\n  patternMemorySaved: patternSaved !== null,\n  versionIncremented: versionSaved !== null,\n  newCognitiveVersion: learningData.learnings.shouldIncrementVersion ? (learningData.originalDecision.cognitiveVersion + 1) : learningData.originalDecision.cognitiveVersion,\n  evaluationSummary: learningData.evaluationSummary,\n  success: true,\n  message: 'Feedback learning loop completed successfully'\n};"
      },
      "id": "consolidate-learning-results",
      "name": "Consolidate Learning Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 300]
    }
  ],
  "connections": {
    "Cron - Every Hour": {
      "main": [[{ "node": "Prepare Evaluation Times", "type": "main", "index": 0 }]]
    },
    "Prepare Evaluation Times": {
      "main": [[{ "node": "HTTP Request - Get Publishing Jobs", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Get Publishing Jobs": {
      "main": [[{ "node": "Prepare Jobs for Evaluation", "type": "main", "index": 0 }]]
    },
    "Prepare Jobs for Evaluation": {
      "main": [
        [
          { "node": "HTTP Request - Get Job Metrics", "type": "main", "index": 0 },
          { "node": "HTTP Request - Get Marketing Pack", "type": "main", "index": 0 },
          { "node": "HTTP Request - Load Pattern Memory", "type": "main", "index": 0 }
        ]
      ]
    },
    "HTTP Request - Get Job Metrics": {
      "main": [[{ "node": "Consolidate Metrics", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Get Marketing Pack": {
      "main": [[{ "node": "Consolidate Metrics", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Load Pattern Memory": {
      "main": [[{ "node": "Consolidate Metrics", "type": "main", "index": 0 }]]
    },
    "Consolidate Metrics": {
      "main": [[{ "node": "Calculate Escalated Penalty", "type": "main", "index": 0 }]]
    },
    "Calculate Escalated Penalty": {
      "main": [[{ "node": "Calculate Block Status", "type": "main", "index": 0 }]]
    },
    "Calculate Block Status": {
      "main": [[{ "node": "Check Override Result", "type": "main", "index": 0 }]]
    },
    "Check Override Result": {
      "main": [[{ "node": "OpenAI - Generate Evaluation Summary", "type": "main", "index": 0 }]]
    },
    "OpenAI - Generate Evaluation Summary": {
      "main": [[{ "node": "Prepare Structured Learnings", "type": "main", "index": 0 }]]
    },
    "Prepare Structured Learnings": {
      "main": [
        [{ "node": "HTTP Request - Save Performance Memory", "type": "main", "index": 0 }],
        [{ "node": "HTTP Request - Save Pattern Memory", "type": "main", "index": 0 }],
        [{ "node": "Check - Increment Version", "type": "main", "index": 0 }]
      ]
    },
    "HTTP Request - Save Performance Memory": {
      "main": [[{ "node": "Consolidate Learning Results", "type": "main", "index": 0 }]]
    },
    "HTTP Request - Save Pattern Memory": {
      "main": [[{ "node": "Consolidate Learning Results", "type": "main", "index": 0 }]]
    },
    "Check - Increment Version": {
      "main": [
        [{ "node": "HTTP Request - Save Version Increment", "type": "main", "index": 0 }],
        [{ "node": "Consolidate Learning Results", "type": "main", "index": 0 }]
      ]
    },
    "HTTP Request - Save Version Increment": {
      "main": [[{ "node": "Consolidate Learning Results", "type": "main", "index": 0 }]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-01T00:00:00.000Z",
      "updatedAt": "2025-01-01T00:00:00.000Z",
      "id": "feedback-loop",
      "name": "Feedback Loop"
    },
    {
      "createdAt": "2025-01-01T00:00:00.000Z",
      "updatedAt": "2025-01-01T00:00:00.000Z",
      "id": "learning",
      "name": "Learning"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "1"
}

